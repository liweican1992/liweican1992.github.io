<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>licc</title>
  
  <subtitle>我心有猛虎 细嗅蔷薇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-15T08:52:32.904Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>weican Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS XCTest实战—解决国际化开发测试痛点（下）</title>
    <link href="http://yoursite.com/2021/10/15/iOS-XCTest%E5%AE%9E%E6%88%98%E2%80%94%E8%A7%A3%E5%86%B3%E5%9B%BD%E9%99%85%E5%8C%96%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%97%9B%E7%82%B9%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2021/10/15/iOS-XCTest%E5%AE%9E%E6%88%98%E2%80%94%E8%A7%A3%E5%86%B3%E5%9B%BD%E9%99%85%E5%8C%96%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%97%9B%E7%82%B9%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2021-10-15T04:11:00.000Z</published>
    <updated>2021-12-15T08:52:32.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上篇详见：<a href="https://kms.netease.com/article/45514" target="_blank" rel="noopener">iOS XCTest实战—解决国际化开发测试痛点（上）</a></p></blockquote><h1 id="4-StoreKit-Configuration-File（无订阅需求可略过）"><a href="#4-StoreKit-Configuration-File（无订阅需求可略过）" class="headerlink" title="4. StoreKit Configuration File（无订阅需求可略过）"></a>4. StoreKit Configuration File（无订阅需求可略过）</h1><p>因为我们是海外订阅类App，这个测试脚本最初的目的就是为了测试订阅页以及整个购买流程，因此要对主要国家的货币和价格进行测试。<br>但是在Xcode12中，模拟器并不能读取线上的<code>SKProuduct</code>信息（Xcode13已经修复）。而真机测试也只能每次手动切换沙盒账户来切换国际和货币币种。<br>如下图所示，订阅页需要适配一些超长的货币（一般坦桑尼亚货币最长）。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215163909.png" alt=""><br>通过<code>StoreKit</code>可以很方便的解决这个问题。<br>Apple 在 Xcode12 中引入了本地 StoreKit 测试，无需连接到 App Store 服务器即可测试不同的 IAP 场景。<br>更多信息详见：<a href="https://developer.apple.com/documentation/xcode/setting-up-storekit-testing-in-xcode#Overview" target="_blank" rel="noopener">《Setting Up StoreKit Testing in Xcode》</a></p><h2 id="i-创建StoreKit-Configuration-File"><a href="#i-创建StoreKit-Configuration-File" class="headerlink" title="i.创建StoreKit Configuration File"></a>i.创建StoreKit Configuration File</h2><p>创建方式很简单，在新建文件中找到<code>StoreKit Configuration File</code><br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215163923.png" alt=""><br>点击加号，新增一个自动续期SKU,当然也可以用来测试消耗类内购。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215163934.png" alt=""></p><p>按着真实的线上SKU进行配置，还能配置推介促销优惠、促销优惠、家庭共享等功能。价格这里只需要填写金额<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215163946.png" alt=""><br>在Schemes设置中，添加刚刚配置的StoreKit Configuration<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164022.png" alt=""></p><p>重新运行项目，就能在获取<code>SKProductsRequestDelegate</code>的<code>productsRequest</code>方法中拿到模拟的SKU了，金额默认是美元。</p><p>而更改货币也很方便，在项目中选中StoreKit Configuration文件，在Xcode中的<code>Editor</code>—&gt;<code>Default Storefront</code>中进行选择相应的币种。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164039.png" alt=""><br>只需要在StoreKit Configuration中更改价格就行了，会自动读取设置的Storefront币种。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164057.png" alt=""></p><p>更改Storefront本质上就是更改<code>SKProduct</code>的<code>priceLocale</code>,注意最终价格的呈现方式要用系统提供的<code>NumberFormatter</code>来计算</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> formatter = <span class="module-access"><span class="module"><span class="identifier">NumberFormatter</span>.</span></span>init<span class="literal">()</span></span><br><span class="line">formatter.formatterBehavior = <span class="module-access"><span class="module"><span class="identifier">NumberFormatter</span>.</span><span class="module"><span class="identifier">Behavior</span>.</span></span>behavior10_4</span><br><span class="line">formatter.numberStyle = <span class="module-access"><span class="module"><span class="identifier">NumberFormatter</span>.</span><span class="module"><span class="identifier">Style</span>.</span></span>currency</span><br><span class="line">formatter.locale = product.priceLocale</span><br><span class="line">self.price = formatter.<span class="built_in">string</span>(from: product.price) ?? <span class="string">""</span></span><br></pre></td></tr></table></figure><h2 id="ii-在XCTest中使用StoreKit-Configuration-File"><a href="#ii-在XCTest中使用StoreKit-Configuration-File" class="headerlink" title="ii. 在XCTest中使用StoreKit Configuration File"></a>ii. 在XCTest中使用StoreKit Configuration File</h2><p>刚刚的配置只是在<code>Schemes</code>的<code>Run</code>环境下配置了StoreKit Configuration<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164137.png" alt=""><br>而在我们需要的<code>Test</code>环境下并没有配置入口<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164204.png" alt=""></p><p>因此需要用代码来解决</p><p>首先找到StoreKit Configuration，把文件共享给UITests Target<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164212.png" alt=""></p><p>然后在需要用到StoreKit Configuration的test方法中，根据新建name新建<code>SKTestSession</code><br>更多信息请参考：<a href="https://developer.apple.com/documentation/storekittest/sktestsession" target="_blank" rel="noopener">《SKTestSession | Apple Developer Documentation》</a></p><blockquote><p>注意：想要在自动化测试中使用StoreKit Configuration，需要用到SKTestSession，只有iOS14以上才支持。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSubscribePage</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> #available(iOS <span class="number">14.0</span>, *) &#123;</span><br><span class="line">           <span class="keyword">let</span> session = <span class="keyword">try</span>? <span class="type">SKTestSession</span>.<span class="keyword">init</span>(configurationFileNamed: <span class="string">"Configuration"</span>)</span><br><span class="line">           session?.disableDialogs = <span class="literal">true</span></span><br><span class="line">           session?.clearTransactions()</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ....</span><br><span class="line">       &#125;</span><br><span class="line">       .....</span><br></pre></td></tr></table></figure><h1 id="5-xcodebuild"><a href="#5-xcodebuild" class="headerlink" title="5. xcodebuild"></a>5. xcodebuild</h1><p>执行完上述步骤，已经可以对单个模拟器或真机执行Test Plans。如果想一次执行多个机型，就需要用到<code>xcodebuild</code>命令了。<br>熟悉Jenkins打包的同学应该对<code>xcodebuild</code>很熟悉，其实我们每次在Xcode进行的<code>Run</code>、<code>Build</code>、<code>Archive</code>等操作本质上都是执行相应的<code>xcodebuild</code>命令。<br>使用<code>xcodebuild</code>命令运行Test Plans命令如下</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用了pod的话就需要执行xxx.xcworkspace</span></span><br><span class="line"><span class="comment">//scheme 选择UITest</span></span><br><span class="line">xcodebuild test -workspace <span class="built_in">UITestDemo</span>.xcworkspace -scheme <span class="built_in">UITestDemoUITests</span> -destination <span class="string">'platform=iOS Simulator,name=iPhone 12 Pro Max,OS=14.5'</span></span><br></pre></td></tr></table></figure><h2 id="i-同时运行多个模拟器和真机"><a href="#i-同时运行多个模拟器和真机" class="headerlink" title="i. 同时运行多个模拟器和真机"></a>i. 同时运行多个模拟器和真机</h2><p>一次运行多个模拟器也是可以的，还可以真机模拟器一起运行，支持不同iOS版本的模拟器同时运行。</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">xcodebuild test -workspace UITestDemo.xcworkspace -scheme UITestDemoUITests </span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">12</span> Pro Max,<span class="attr">OS=14.5'</span> </span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">12</span>,<span class="attr">OS=14.5'</span></span><br><span class="line"> -destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">8</span> Plus,<span class="attr">OS=14.5'</span> </span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">8</span>,<span class="attr">OS=14.5'</span> </span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> SE (<span class="number">2</span>nd generation),<span class="attr">OS=14.5'</span></span><br><span class="line">-destination '<span class="attr">platform=iOS,name=caniPhone'</span></span><br></pre></td></tr></table></figure><blockquote><p>注意模拟器和真机的Name必须准确，查看所有可执行的模拟器和真机可以使用<code>xcrun xctrace list devices</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164226.png" alt=""></p><h2 id="ii-指定derivedDataPath"><a href="#ii-指定derivedDataPath" class="headerlink" title="ii. 指定derivedDataPath"></a>ii. 指定derivedDataPath</h2><p>正常运行Test Plans，运行结果只能在Xcode中查看并且路径很深，也可以使用<code>derivedDataPath</code>指定结果的输出路径</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">xcodebuild test -workspace UITestDemo.xcworkspace -scheme UITestDemoUITests -derivedDataPath '/Users/cc/Desktop/outData'</span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">12</span> Pro Max,<span class="attr">OS=14.5'</span> </span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">12</span>,<span class="attr">OS=14.5'</span></span><br><span class="line"> -destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">8</span> Plus,<span class="attr">OS=14.5'</span> </span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">8</span>,<span class="attr">OS=14.5'</span> </span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> SE (<span class="number">2</span>nd generation),<span class="attr">OS=14.5'</span></span><br><span class="line">-destination '<span class="attr">platform=iOS,name=caniPhone'</span></span><br></pre></td></tr></table></figure><h2 id="iii-开启parallel"><a href="#iii-开启parallel" class="headerlink" title="iii. 开启parallel"></a>iii. 开启parallel</h2><p>在<a href="https://kms.netease.com/article/45514" target="_blank" rel="noopener">iOS XCTest实战—解决国际化开发测试痛点（上）</a>中Test Plans栏目介绍了为设备开启parallel testing。在xcode build中同样可以使用<code>-parallel-testing-enabled YES -parallelize-tests-among-destinations</code>开启（不过同时运行多个不同的模拟器，一般没有额外资源对同一个模拟器再开启parallel testing）</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">xcodebuild test -workspace UITestDemo.xcworkspace -scheme UITestDemoUITests -derivedDataPath '/Users/cc/Desktop/outData'</span><br><span class="line">-parallel-testing-enabled YES -parallelize-tests-among-destinations</span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">12</span> Pro Max,<span class="attr">OS=14.5'</span> </span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">12</span>,<span class="attr">OS=14.5'</span></span><br><span class="line"> -destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">8</span> Plus,<span class="attr">OS=14.5'</span> </span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> <span class="number">8</span>,<span class="attr">OS=14.5'</span> </span><br><span class="line">-destination '<span class="attr">platform=iOS</span> Simulator,<span class="attr">name=iPhone</span> SE (<span class="number">2</span>nd generation),<span class="attr">OS=14.5'</span></span><br><span class="line">-destination '<span class="attr">platform=iOS,name=caniPhone'</span></span><br></pre></td></tr></table></figure><blockquote><p>系统会按照可用资源同时并行运行多个模拟器(一般是5个)，当你指定超过5个，最开始运行结束的模拟器会自动关闭然后运行下一个。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164352.png" alt=""></p><p>更多的xcodebuild详见:</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">man xcodebuild</span></span><br></pre></td></tr></table></figure><h1 id="6-从xcresult中提取截图"><a href="#6-从xcresult中提取截图" class="headerlink" title="6. 从xcresult中提取截图"></a>6. 从xcresult中提取截图</h1><p>上面提到过要看Test Plans运行完后的截图，只能在Xcode中查看，并且每次只能查看一个配置，图片也只能一次查看一张。<br>在Xcode中找到测试结果，在Finder中显示可以看到结果是以<code>.xcresult</code>结尾的文件<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164427.png" alt=""><br>点击显示包内容后发现结果也无法读取。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164442.png" alt=""></p><p>通过查阅官方文档：<a href="https://help.apple.com/xcode/mac/current/#/devc38fc7392" target="_blank" rel="noopener">《View and share test results》</a>得知，可以使用<code>xcrun xcresulttool</code>命令来导出结果。<br>更多命令请查看</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">xcrun xcresulttool --<span class="keyword">help</span> </span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">man</span> xcresulttool</span><br></pre></td></tr></table></figure><h2 id="i-xcparse"><a href="#i-xcparse" class="headerlink" title="i.xcparse"></a>i.xcparse</h2><p>但是其实不用这么麻烦，因为在Github上有很好用的开源库：<a href="https://github.com/ChargePoint/xcparse" target="_blank" rel="noopener">xcparse</a></p><p>通过<code>brew</code>安装后，运行xcparse命令即可</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">//install</span>  xcparse</span><br><span class="line">brew install chargepoint/xcparse/xcparse</span><br><span class="line"></span><br><span class="line"><span class="string">//run</span> xcparse</span><br><span class="line">xcparse screenshots <span class="params">--os</span> <span class="params">--model</span> <span class="params">--test-plan-config</span> <span class="string">/path/to/Test.xcresult</span> <span class="string">/path/to/outputDirectory</span></span><br></pre></td></tr></table></figure><p>得到的结果就会按机型、语言分组展示，清晰明了。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215164459.png" alt=""></p><h1 id="7-最终方案Shell脚本"><a href="#7-最终方案Shell脚本" class="headerlink" title="7. 最终方案Shell脚本"></a>7. 最终方案Shell脚本</h1><p>做完上述所有操作，就已经基本满足需求了。但是还是差那么点意思，目前还存在以下问题：</p><ul><li>每次改模拟器，都需要修改xcodebuild命令</li><li>输出path要手动指定，如果存在也不会覆盖会一直增加</li><li>运行完xcodebuild命令后，要导出图片还要手动执行xcparse命令</li><li>无法部署到Jenkins等让非开发人员去测试<br>….</li></ul><p>所以我用了一段时间后，决定要shell脚本封装一下，做到一键操作。只需要一个命令，就可以自动执行<code>Test Plans</code>,拿到<code>xcresult</code>后自动执行<code>xcparse</code>命令导出到指定路径。</p><p>因为所有的难题之前已经解决了，脚本也是水到渠成。逻辑也很简单</p><h2 id="i-脚本"><a href="#i-脚本" class="headerlink" title="i.脚本"></a>i.脚本</h2><ul><li><p>先指定scheme名字</p></li><li><p>指定xcresult输出目录和xcparse图片输出目录，之前存在就覆盖</p></li><li><p>配置模拟器和真机List</p></li><li><p>test plans运行完毕后拿到xcresult，用xcparse导出图片</p></li></ul><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  UITest.sh</span></span><br><span class="line"><span class="comment">#  UDictionary</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Created by 李伟灿 on 2021/8/24.</span></span><br><span class="line"><span class="comment">#  Copyright © 2021 com.youdao. All rights reserved.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#chmod +x UITest.sh</span></span><br><span class="line"><span class="comment">#./UITest.sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"=========开始执行========="</span></span><br><span class="line"></span><br><span class="line">path=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"path is <span class="variable">$path</span>"</span></span><br><span class="line"></span><br><span class="line">scheme=<span class="string">"UDictionary"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出目录</span></span><br><span class="line">outPath=<span class="string">"<span class="variable">$HOME</span>/Desktop/outData"</span></span><br><span class="line">resultPath=<span class="string">"<span class="variable">$HOME</span>/Desktop/outResult"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#XCUITest function</span></span><br><span class="line"><span class="function"><span class="title">xcUITestFunc</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -e <span class="variable">$scheme</span>.xcodeproj</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'=========Xcode Project存在'</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'=========Xcode Project不存在 请检查执行路径'</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -e <span class="variable">$outPath</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"=========outPath existed, clean outPath"</span></span><br><span class="line">        rm -rf <span class="variable">$outPath</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    mkdir <span class="variable">$outPath</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"=========outPath mkdir"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Get All Devices</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#xcrun xctrace list devices</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#兼容真机和模拟器 不过最好模拟器一起跑 真机一起跑</span></span><br><span class="line">    simulators=(</span><br><span class="line">                <span class="comment">#iPhone</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPhone 12 Pro Max,OS=15.0"</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPhone 12,OS=15.0"</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPhone 8 Plus,OS=15.0"</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPhone 8,OS=15.0"</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPhone SE (2nd generation),OS=15.0"</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">#iPad</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPad (9th generation),OS=15.0"</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPad mini (6th generation),OS=15.0"</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPad Air (4th generation),OS=15.0"</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPad Pro (9.7-inch),OS=15.0"</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPad Pro (11-inch) (3rd generation),OS=15.0"</span></span><br><span class="line">                <span class="string">"platform=iOS Simulator,name=iPad Pro (12.9-inch) (5th generation),OS=15.0"</span></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    destinationStr=<span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> subSimulator <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;simulators[@]&#125;</span>"</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        tmpStr=<span class="string">"-destination '<span class="variable">$subSimulator</span>' "</span></span><br><span class="line">        destinationStr=<span class="variable">$destinationStr</span><span class="variable">$tmpStr</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$destinationStr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#拼接命令</span></span><br><span class="line">    commandStr=<span class="string">"xcodebuild test -workspace <span class="variable">$scheme</span>.xcworkspace -scheme <span class="variable">$scheme</span> -derivedDataPath '<span class="variable">$outPath</span>' <span class="variable">$destinationStr</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$commandStr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#执行命令</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$commandStr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"=========XCTestPlan执行结束========="</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"----------------------------------"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"----------------------------------"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">getAllScreenShots</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -e <span class="variable">$resultPath</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"=========resultPath existed, clean resultPath"</span></span><br><span class="line">        rm -rf <span class="variable">$resultPath</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#find xcresult</span></span><br><span class="line">    xcresultpath=$(find <span class="variable">$outPath</span>/Logs/Test -name <span class="string">"*.xcresult"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"=========即将输出图片到<span class="variable">$resultPath</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Install xcparse</span></span><br><span class="line">    <span class="comment">#brew install chargepoint/xcparse/xcparse</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#执行xcparse</span></span><br><span class="line">    commandStr=<span class="string">"xcparse screenshots --os --model --test-plan-config <span class="variable">$xcresultpath</span> <span class="variable">$resultPath</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$commandStr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#执行命令</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$commandStr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"=========xcparse执行结束========="</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xcUITestFunc</span><br><span class="line"></span><br><span class="line">getAllScreenShots</span><br></pre></td></tr></table></figure><h2 id="ii-运行脚本"><a href="#ii-运行脚本" class="headerlink" title="ii.运行脚本"></a>ii.运行脚本</h2><p>运行方式也很简单，在Terminal中找到工程目录，执行Shell脚本，比如我们Shell脚本为UITest.sh</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">chmod +x <span class="module-access"><span class="module"><span class="identifier">UITest</span>.</span></span>sh</span><br><span class="line">./<span class="module-access"><span class="module"><span class="identifier">UITest</span>.</span></span>sh</span><br></pre></td></tr></table></figure><h1 id="8-结语"><a href="#8-结语" class="headerlink" title="8.结语"></a>8.结语</h1><p>至此，UI自动走查方案已经全部完成了。有了这个脚本后，我们工程每个版本开发自测和测试平均节省了<code>5/人/天</code>的工作量。特别是后来我们开启了iPad适配后。而UI走查也能看到最终结果的真实呈现。目前已经稳定运行了4个多月，后续还会根据需求继续优化。<br>本方案设计到很多技术点，比如<code>XCTest</code>、<code>Test Plans</code>、<code>xcodebuild</code>、<code>StoreKit Configuration</code>等等，每一部分单独拎出来说都可以单独写一篇。<br>所以本文很多地方都一笔带过，主要讲方案的选择和融合。如果哪方面有疑问欢迎大家联系我进行讨论和交流。</p><h2 id="联系方式："><a href="#联系方式：" class="headerlink" title="联系方式："></a>联系方式：</h2><blockquote><p>李伟灿<br>网易有道 国际词典项目组<br><a href="https://github.com/liweican1992" target="_blank" rel="noopener">Github</a><br>liweican#corp.netease.com<br>liweican1992#163.com</p></blockquote><p>感谢您的阅读~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上篇详见：&lt;a href=&quot;https://kms.netease.com/article/45514&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS XCTest实战—解决国际化开发测试痛点（上）&lt;/a&gt;&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS XCTest实战—解决国际化开发测试痛点（上）</title>
    <link href="http://yoursite.com/2021/10/11/iOS-XCTest%E5%AE%9E%E6%88%98%E2%80%94%E8%A7%A3%E5%86%B3%E5%9B%BD%E9%99%85%E5%8C%96%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%97%9B%E7%82%B9/"/>
    <id>http://yoursite.com/2021/10/11/iOS-XCTest%E5%AE%9E%E6%88%98%E2%80%94%E8%A7%A3%E5%86%B3%E5%9B%BD%E9%99%85%E5%8C%96%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%97%9B%E7%82%B9/</id>
    <published>2021-10-11T07:34:00.000Z</published>
    <updated>2021-12-15T08:59:47.040Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>海外项目一定离不开国际化适配，而国际化文案的展示&amp;机型适配一直是开发和测试中的痛点。<br>本人负责的项目一直深耕海外，目前支持13种国际化语言包括R2L的阿拉伯语。作为订阅类App，需要进行大量的订阅页AB测试。本文主要介绍了在项目中如何利用<code>XCTest</code>、<code>Test Plan</code>、<code>StoreKit Configuration</code>、<code>xcodebuild</code>命令、<code>Shell</code>脚本进行快速UI走查的。</p></blockquote><h1 id="0-国际化痛点"><a href="#0-国际化痛点" class="headerlink" title="0.国际化痛点"></a>0.国际化痛点</h1><p>在国际化日常开发中，国际化文案适配是一个难题，除了开发需要考虑各种换行和边界问题等，测试同学也要花精力挨个语种和机型进行走查。尤其是订阅页面各个国家的货币展示页不相同。<br>下图列举了一些国际化常见的问题：<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215160447.png" alt=""><br>⬆️换行后依旧无法展示<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215165931.png" alt=""><br>⬆️文案过长，小屏幕机型展示问题<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215160349.png" alt=""><br>⬆️货币价格过长，需要额外适配</p><hr><p>这些问题都需要开发自测或UI走查才能发现，下面我们一起来解决这些痛点。</p><h1 id="1-需求梳理"><a href="#1-需求梳理" class="headerlink" title="1.需求梳理"></a>1.需求梳理</h1><p>开始之前先梳理一下需求，通过平时我自测的痛点以及和测试同学的沟通，如果用脚本进行测试需要达到以下效果：</p><ol><li>所有国际化文案和主要机型都要覆盖</li><li>以页面截图为准，人工过一下，方便发现问题和报bug，最重要的是方便后期UI Debug。</li><li>对订阅功能，可以方便切换不同国家展示不同的货币</li><li>脚本要方便使用，可以方便配置不同的机型、国际化语言和货币币种，后期方便部署到Jenkins</li><li>结果呈现要分机型、iOS系统，通过截图名称可以知道是哪个页面</li></ol><h1 id="2-XCTest"><a href="#2-XCTest" class="headerlink" title="2.XCTest"></a>2.XCTest</h1><p><code>XCTest</code>是Xocde的原生测试框架。相对于<a href="https://github.com/kiwi-bdd/Kiwi" target="_blank" rel="noopener">Kiwi</a>、<a href="https://github.com/specta/specta" target="_blank" rel="noopener">Specta</a>、<a href="https://github.com/specta/expecta" target="_blank" rel="noopener">Expecta</a>等第三方框架更容易上手。而选择<code>XCTest</code>还有一个重要的原因是Apple在2019 WWDC推出的<code>Test Plans</code>对国际化测试非常友好。</p><p>(详见：<a href="https://developer.apple.com/videos/play/wwdc2019/413/" target="_blank" rel="noopener">Testing in Xcode</a>，下文也会详细介绍）</p><p>Xcode在创建项目时候一般会自动创建Test和UITest工程，因为只需要测试UI，使用UITest即可。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215160550.png" alt=""><br>具体的XCTest文档详见<a href="https://developer.apple.com/documentation/xctest/user_interface_tests" target="_blank" rel="noopener">User Interface Tests</a>，这里就不展开讲了。</p><p>在开始写测试脚本之前，我们需要解决以下几个问题：</p><h2 id="i-对页面进行截图"><a href="#i-对页面进行截图" class="headerlink" title="i.对页面进行截图"></a>i.对页面进行截图</h2><p>截图方法很简单，封装成一个方法如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takeAScreenshot</span><span class="params">(<span class="number">_</span> name: String)</span></span> &#123;</span><br><span class="line">      <span class="keyword">let</span> screenshot = <span class="type">XCUIScreen</span>.main.screenshot()</span><br><span class="line">      <span class="keyword">let</span> screenshotAttachment = <span class="type">XCTAttachment</span>(</span><br><span class="line">          uniformTypeIdentifier: <span class="string">"public.png"</span>,</span><br><span class="line">          name: <span class="string">"Screenshot-\(UIDevice.current.name)-\(name).png"</span>,</span><br><span class="line">          payload: screenshot.pngRepresentation,</span><br><span class="line">          userInfo: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">      screenshotAttachment.lifetime = .keepAlways</span><br><span class="line">      add(screenshotAttachment)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>还可以指定截图的质量，比如我们工程运行一次脚本需要截图500+，就需要指定低质量了。经过测试低质量的图片占用大小比高质量能压缩近20倍左右。但是需要注意，在M1芯片的Mac上，指定质量的截图方法会报错，应该是Xcode的适配问题。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">func take<span class="constructor">AScreenshot(<span class="params">_</span> <span class="params">name</span>: String)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> screenshot = <span class="module-access"><span class="module"><span class="identifier">XCUIScreen</span>.</span></span>main.screenshot<span class="literal">()</span></span><br><span class="line">      <span class="keyword">let</span> screenshotAttachment = <span class="module-access"><span class="module"><span class="identifier">XCTAttachment</span>.</span></span>init(screenshot: screenshot, quality: .low)</span><br><span class="line">      screenshotAttachment.name = <span class="string">"\(UIDevice.current.name)-\(name).jpeg"</span></span><br><span class="line">      screenshotAttachment.lifetime = .keepAlways</span><br><span class="line">      add(screenshotAttachment)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试完成后，截图可以在Xcode中查看<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215160607.png" alt=""></p><h2 id="ii-国际化适配"><a href="#ii-国际化适配" class="headerlink" title="ii. 国际化适配"></a>ii. 国际化适配</h2><p>在XCTest中，我们可以模拟用户的操作，比如点击一个按钮，点击一个Label等，而找到控件的方式一般是按Button文本或者Label的Text.<br>比如我页面有一个Button，title是“testButton”</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">func test<span class="constructor">Example()</span> throws &#123;</span><br><span class="line">     <span class="comment">// UI tests must launch the application that they test.</span></span><br><span class="line">     <span class="keyword">let</span> btn = app.buttons<span class="literal">["<span class="identifier">testButton</span>"]</span></span><br><span class="line">     <span class="constructor">XCTAssertTrue(<span class="params">btn</span>.<span class="params">exists</span>)</span></span><br><span class="line">     <span class="comment">//tap btn</span></span><br><span class="line">     btn.tap<span class="literal">()</span></span><br><span class="line">     sleep(<span class="number">2</span>)</span><br><span class="line">     take<span class="constructor">AScreenshot(<span class="string">"button"</span>)</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>但是当我开启国际化后，按钮文案是跟随系统语言变化的，那上述代码就会执行失败。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215160630.png" alt=""></p><p>解决办法是为控件设置<code>accessibilityIdentifier</code>属性。<code>accessibilityIdentifier</code>是专为UITest设计的。可以方便的找到需要的元素。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为btn设置accessibilityIdentifier</span></span><br><span class="line">btn<span class="selector-class">.accessibilityIdentifier</span> = <span class="string">"myTestButton"</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//在XCTest中 按accessibilityIdentifier查找</span></span><br><span class="line">let btn = app<span class="selector-class">.buttons</span>[<span class="string">"myTestButton"</span>]</span><br></pre></td></tr></table></figure><h2 id="iii-主App开启测试环境"><a href="#iii-主App开启测试环境" class="headerlink" title="iii. 主App开启测试环境"></a>iii. 主App开启测试环境</h2><p>XCTest每次运行都会重新运行App，一般主App启动入口会有很多业务逻辑，对测试会造成影响。我们需要判断本次启动是从XCTest启动的，这样可以开启测试环境，去掉一些无关的逻辑。<br>在UITest中可以向<code>launchArguments</code>中加入自定义参数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UITestDemoUITests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> app: <span class="type">XCUIApplication!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUpWithError</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line"></span><br><span class="line">        continueAfterFailure = <span class="literal">false</span></span><br><span class="line">        app = <span class="type">XCUIApplication</span>()</span><br><span class="line">        <span class="comment">//向主App传递参数 也可以写在测试方法中</span></span><br><span class="line">        app.launchArguments.append(<span class="string">"UDUIXCTestConfig#SubscribePage"</span>)</span><br><span class="line">        app.launch()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Appdelegate</code>的<code>didFinishLaunchingWithOptions</code>中判断，可以指定根据字符串指定需要测试的场景。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: <span class="literal">[UIA<span class="identifier">pplication</span>.L<span class="identifier">aunchOptionsKey</span>: A<span class="identifier">ny</span>]</span>?) -&gt; Bool &#123;</span><br><span class="line">    ...</span><br><span class="line">      for subArgue: String <span class="keyword">in</span> <span class="module-access"><span class="module"><span class="identifier">CommandLine</span>.</span></span>arguments &#123;</span><br><span class="line">            <span class="keyword">if</span> subArgue.has<span class="constructor">Prefix(<span class="string">"UDUIXCTestConfig"</span>)</span> &#123;</span><br><span class="line">                <span class="comment">//开启测试模式</span></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">UDXCTestManager</span>.</span></span>share<span class="constructor">Instance()</span>.argument = subArgue</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">UDXCTestManager</span>.</span></span>share<span class="constructor">Instance()</span>.testModeOn = <span class="literal">true</span></span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iv-Demo"><a href="#iv-Demo" class="headerlink" title="iv. Demo"></a>iv. Demo</h2><blockquote><p>开启上述步骤后，已经可以初步进行UI测试了，通过设置测试环境，确保启动后进入待测试页面。合理利用for循环以及截图。需要注意接入前如果涉及页面跳转等，要用sleep()函数等待页面渲染完后再截图</p></blockquote><p>比如我们工程中一个测试方法</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">func test<span class="constructor">SubscribePage()</span> throws &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> #available(iOS <span class="number">14.0</span>, *) &#123;</span><br><span class="line">          <span class="keyword">let</span> session = <span class="keyword">try</span>? <span class="module-access"><span class="module"><span class="identifier">SKTestSession</span>.</span></span>init(configurationFileNamed: <span class="string">"Configuration"</span>)</span><br><span class="line">          session?.disableDialogs = <span class="literal">true</span></span><br><span class="line">          session?.clear<span class="constructor">Transactions()</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      app.launchArguments.append(<span class="string">"UDUIXCTestConfig#SubscribePage"</span>)</span><br><span class="line">      app.launch<span class="literal">()</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> TypeList = <span class="literal">["S", "T", "U", "V", "V3"]</span></span><br><span class="line">      for sub <span class="keyword">in</span> TypeList &#123;</span><br><span class="line">          <span class="keyword">let</span> typeElement = app.tables.staticTexts<span class="literal">[<span class="identifier">sub</span>]</span></span><br><span class="line">          <span class="constructor">XCTAssertTrue(<span class="params">typeElement</span>.<span class="params">exists</span>)</span></span><br><span class="line">          typeElement.tap<span class="literal">()</span></span><br><span class="line">          sleep(<span class="number">2</span>)</span><br><span class="line">          self.take<span class="constructor">AScreenshot(<span class="string">"\(sub) List"</span>)</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//测试子页面</span></span><br><span class="line">          <span class="keyword">let</span> <span class="built_in">list</span> = <span class="literal">["<span class="identifier">weekly_free</span>", "<span class="identifier">monthly_free</span>", "<span class="identifier">yearly_free</span>"]</span></span><br><span class="line">          for sublist <span class="keyword">in</span> <span class="built_in">list</span> &#123;</span><br><span class="line">              sleep(<span class="number">2</span>)</span><br><span class="line">              <span class="keyword">let</span> subtypeElement = app.tables.staticTexts<span class="literal">[<span class="identifier">sublist</span>]</span></span><br><span class="line">              <span class="constructor">XCTAssertTrue(<span class="params">subtypeElement</span>.<span class="params">exists</span>)</span></span><br><span class="line">              <span class="comment">//进入待测试页</span></span><br><span class="line">              subtypeElement.tap<span class="literal">()</span></span><br><span class="line">              sleep(<span class="number">2</span>)</span><br><span class="line">              self.take<span class="constructor">AScreenshot(<span class="string">"\(sub)-\(sublist)-1"</span>)</span></span><br><span class="line">              sleep(<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">if</span> sub<span class="operator"> == </span><span class="string">"S"</span><span class="operator"> || </span>sub<span class="operator"> == </span><span class="string">"T"</span> &#123;</span><br><span class="line">                  <span class="comment">//滚动到底部</span></span><br><span class="line">                  app.swipe<span class="constructor">Up()</span></span><br><span class="line">                  sleep(<span class="number">1</span>)</span><br><span class="line">                  <span class="comment">//对底部截图 无法滚动的页面可以考虑过滤掉</span></span><br><span class="line">                  self.take<span class="constructor">AScreenshot(<span class="string">"\(sub)-\(sublist)-2"</span>)</span></span><br><span class="line">                  sleep(<span class="number">3</span>)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  sleep(<span class="number">4</span>)</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//返回上一页面</span></span><br><span class="line">          <span class="keyword">let</span> backButton = <span class="constructor">XCUIApplication()</span>.navigationBars.buttons<span class="literal">["<span class="identifier">backButton</span>"]</span></span><br><span class="line">          <span class="constructor">XCTAssert(<span class="params">backButton</span>.<span class="params">exists</span>)</span></span><br><span class="line">          backButton.tap<span class="literal">()</span></span><br><span class="line">          sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="3-TestPlans"><a href="#3-TestPlans" class="headerlink" title="3.TestPlans"></a>3.TestPlans</h1><p>上述方案每次只能测试一个国际化语言，每次切换语言后需要重新运行。在<code>TestPlans</code>推出之前需要我们自己写<code>xcodebuild</code>命令来指定国际化语言或者在Schemes中配置App Langauge<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215160655.png" alt=""></p><p><code>TestPlans</code>是Apple在2019年WWDC推出的测试工具，详细信息详见<a href="https://developer.apple.com/videos/play/wwdc2019/413/" target="_blank" rel="noopener">《Testing in Xcode》</a>, 推出后可以更方便的进行国际化语言以及其余配置的切换。</p><p>开启方式也很简单，在“Edit Scheme..”—&gt; “Test” —&gt; “Covert to use Test Plans”<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215160726.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215160746.png" alt=""><br>选择放到主工程中，设置成Default<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215160807.png" alt=""></p><h2 id="i-配置Configuration"><a href="#i-配置Configuration" class="headerlink" title="i. 配置Configuration"></a>i. 配置Configuration</h2><p>在主工程中找到<code>.xctestplan</code>后缀的文件。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215161029.png" alt=""><br>可以发现在Configuration中可以设置语言、地区、开启<code>Code Coverage</code>等功能。</p><p>可以点击加号加新的配置文件，默认的配置是读取Share Settings的配置。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215161044.png" alt=""><br>比如我们的工程，配置了主要适配的语言。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215161113.png" alt=""></p><h2 id="ii-选择测试方法、开启并行"><a href="#ii-选择测试方法、开启并行" class="headerlink" title="ii. 选择测试方法、开启并行"></a>ii. 选择测试方法、开启并行</h2><p>在Test面板，可以看到所有测试方法，可以勾选需要测试的方法，勾选多个会按着从上到下的顺序执行。在Options中打开<code>Execute in parallel</code>。打开后可以在资源允许的情况下，开启多个克隆的模拟器，提高测试速度。</p><blockquote><p>比如执行Phone X机型的一个测试方法，在Configuration中配置了6个配置文件，资源允许情况下会开启3个iPhone X模拟器，每个模拟器跑2个配置，速度提高了3倍。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215161123.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215161136.png" alt=""></p><h2 id="iii-运行Test-Plans"><a href="#iii-运行Test-Plans" class="headerlink" title="iii.  运行Test Plans"></a>iii.  运行Test Plans</h2><p><code>Test Plans</code>的运行方式和之前一样，找到之前的方法入口，点击运行或者按右键只运行部分配置<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215161152.png" alt=""></p><h2 id="iv-查看结果"><a href="#iv-查看结果" class="headerlink" title="iv. 查看结果"></a>iv. 查看结果</h2><p>Test Plans运行完后可以在Xcode中查看结果，如果运行多个配置，每个配置的结果都会单独呈现<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215161209.png" alt=""></p><blockquote><p>国际化测试需要注意，在Configuration中有<code>Localization Screenshots</code>选型，默认是<code>On</code>，只要本页面文件进行了国际化（使用<code>NSLocalizedString</code>）都会自动截图，如不需要可以关闭。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20211215161224.png" alt=""></p><blockquote><p>到目前为止，我们得到了一个初步的测试方案，可以用XCTest写完页面截图逻辑后，使用Test Plans批量运行多个语言。下一章会介绍如何解决订阅中多币种的适配、如何快速导出测试截图以及最终用xcodebuild和shell脚本自动化所有操作。</p></blockquote><h1 id="4-iOS-XCTest实战—解决国际化开发测试痛点（下）"><a href="#4-iOS-XCTest实战—解决国际化开发测试痛点（下）" class="headerlink" title="4.iOS XCTest实战—解决国际化开发测试痛点（下）"></a>4.iOS XCTest实战—解决国际化开发测试痛点（下）</h1><p>下篇详见：<a href="https://kms.netease.com/article/45612" target="_blank" rel="noopener">iOS XCTest实战—解决国际化开发测试痛点（下）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;海外项目一定离不开国际化适配，而国际化文案的展示&amp;amp;机型适配一直是开发和测试中的痛点。&lt;br&gt;本人负责的项目一直深耕海外，目前支持13种国际化语言包括R2L的阿拉伯语。作为订阅类App，需要进行大量的订阅页AB测试。本文主要介绍了在项目中如何
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS国际化—XLIFF批量录入脚本(一键操作)</title>
    <link href="http://yoursite.com/2020/10/12/iOS%E5%9B%BD%E9%99%85%E5%8C%96%E2%80%94Xliff%E5%BD%95%E5%85%A5%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2020/10/12/iOS%E5%9B%BD%E9%99%85%E5%8C%96%E2%80%94Xliff%E5%BD%95%E5%85%A5%E8%84%9A%E6%9C%AC/</id>
    <published>2020-10-12T08:19:00.000Z</published>
    <updated>2021-11-12T03:09:28.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>XLIFF（XML Localisation Interchange File Format，即XML本地化交换文件格式）是一种基于XML的交换格式，旨在标准化本地化过程中在工具之间传递可本地化数据的方式，是CAT工具中常用的一种文件格式。XLIFF由结构化信息标准促进组织（OASIS）于2002年标准化，目前规范为2014年8月5日发布的v2.0<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 ——Wiki</p></blockquote><p>Apple对国际化文案的管理也是基于<code>XLIFF</code>的，这几年一直负责海外项目。国际化文案翻译和录入是必不可免的。XLIFF是业内的通用做法。</p><p>如果你对XLIFF不了解，可以参考WWDC Session 401:<br><a href="https://developer.apple.com/videos/play/wwdc2017/401" target="_blank" rel="noopener">《Localizing with Xcode 9》</a></p><p>Apple在2018年升级了国际化文案管理方式，从<code>XLIFF</code>升级到了<code>Localization Catalog</code>。不过本质上文案管理还是XLIFF。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201012164605.png" alt=""></p><p>具体参考WWDC Session404:<br><a href="https://developer.apple.com/videos/play/wwdc2018/404/" target="_blank" rel="noopener">《New Localization Workflows in Xcode 10》</a></p><p><code>Localization Catalog</code> 解决了XLIFF的单一性，可以让翻译人员根据上下文语境更准确的翻译。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201012165247.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201012164625.png" alt=""></p><hr><p><strong>一般来说，正确的方法是从Xcode中生成<code>Localization Catalog</code>，直接把<code>Localization Catalog</code>给到翻译人员，翻译人员根据storyboard或者图片结合上下文，对文案进行翻译，并且录入到<code>XLIFF</code>中。然后我们只需要导入到Xcode中就可以了。</strong></p><hr><a id="more"></a><p>不过现实中一般都是用<code>Excel</code>进行文案管理，特别是<code>云端Excel</code>，可以方便管理也方便安卓使用。之前推动过XLIFF，用了几次每次都要给对方进行培训。成本太高。</p><p>在写脚本之前，我们用的是<code>XLiffTool</code>这个工具，可以在Mac的App Store直接下载。比较方人工录入。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201012170224.png" alt=""></p><p>但是人工录入耗时耗力还容易出错，特别是我们有十几种国际化语言，每次要录入几千条文案。</p><p>所以考虑用Python撸一个脚本。Python对Excel和XML的读写都很友好。也顺带学习下Python3.8的语法。</p><p>对Excel的读写可以使用<code>xlrd</code>,指定Excel的路径和要读取的sheet。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201012172402.png" alt=""></p><blockquote><p>update：更新了下python文件，支持批量操作</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析xliff的nameSpace Xliff版本变更请更改这里</span></span><br><span class="line">ns = dict(xliffNameSpace=<span class="string">'urn:oasis:names:tc:xliff:document:1.2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># excel地址</span></span><br><span class="line">excelPath = os.path.join(os.path.expanduser(<span class="string">"~"</span>), <span class="string">'Desktop/localizable.xlsx'</span>)</span><br><span class="line"><span class="comment"># xliff根目录</span></span><br><span class="line">xliffRootPath = os.path.join(os.path.expanduser(<span class="string">"~"</span>), <span class="string">'Desktop/exportLoaclization'</span>)</span><br><span class="line"><span class="comment"># 语言list</span></span><br><span class="line">languages = &#123;<span class="string">"Spanish"</span> : <span class="string">"es"</span>, <span class="string">"Portuguese"</span> : <span class="string">"pt"</span>, <span class="string">"Indonesian"</span> : <span class="string">"id"</span>, <span class="string">"Arabic"</span> : <span class="string">"ar"</span>, <span class="string">"Japanese"</span> : <span class="string">"ja"</span>, <span class="string">"Vietnam"</span> : <span class="string">"vi-VN"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标语言 需要和excel中一致</span></span><br><span class="line">targetName = <span class="string">""</span></span><br><span class="line">sourceName = <span class="string">"English"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sheetName 从哪个表读取，找不到会默认读取第一个表</span></span><br><span class="line">sheetName = <span class="string">"ios"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetDesktopPath</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> os.path.join(os.path.expanduser(<span class="string">"~"</span>), <span class="string">'Desktop'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readExcel</span><span class="params">()</span>:</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(excelPath):</span><br><span class="line">        print(<span class="string">'excel路径不存在'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if not os.path.exists(xliffPath):</span></span><br><span class="line">    <span class="comment">#     print('xliff路径不存在')</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line"></span><br><span class="line">    data = xlrd.open_workbook(excelPath)</span><br><span class="line">    <span class="comment"># 拿到索引 默认是在sheet0</span></span><br><span class="line">    sheet1 = data.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> sheetName <span class="keyword">in</span> data.sheet_names():</span><br><span class="line">        sheet1 = data.sheet_by_name(sheetName)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"sheetName不存在 默认读取第一个"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找English索引</span></span><br><span class="line">    sourceIndex = <span class="number">-1</span></span><br><span class="line">    <span class="comment"># 确定Index</span></span><br><span class="line">    row_0 = sheet1.row_values(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(len(row_0)):</span><br><span class="line">        <span class="keyword">if</span> row_0[k] == sourceName:</span><br><span class="line">            sourceIndex = k</span><br><span class="line">            print(sourceName + <span class="string">" 所在索引 "</span> + str(k))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sourceIndex == <span class="number">-1</span>:</span><br><span class="line">        print(<span class="string">'未找到English Index'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#找target索引</span></span><br><span class="line">    <span class="keyword">for</span> subLan <span class="keyword">in</span> languages:</span><br><span class="line">        print(subLan)</span><br><span class="line">        targetName = subLan</span><br><span class="line">        targetIndex = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(row_0)):</span><br><span class="line">            <span class="keyword">if</span> row_0[k] == targetName:</span><br><span class="line">                targetIndex = k</span><br><span class="line">                print(targetName + <span class="string">" 所在索引 "</span> + str(k))</span><br><span class="line">                <span class="comment"># 遍历字典</span></span><br><span class="line">                dict = &#123;&#125;</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(sheet1.nrows):</span><br><span class="line">                    row_value = sheet1.cell_value(i, targetIndex)</span><br><span class="line">                    row_key = sheet1.cell_value(i, sourceIndex)</span><br><span class="line">                    <span class="keyword">if</span> row_key == <span class="string">'English'</span> <span class="keyword">or</span> row_key == <span class="string">""</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    dict[row_key] = row_value</span><br><span class="line">                print(<span class="string">'excel数据读取完毕，共 '</span>, len(dict), <span class="string">' 条数据'</span>)</span><br><span class="line">                print(dict)</span><br><span class="line">                <span class="comment"># 读取Xliff</span></span><br><span class="line">                writeXliff(dict,targetName)</span><br></pre></td></tr></table></figure><p>拿到需要的文案，放到字典里面，然后开始读写XLIFF</p><p>查看XLIFF源码可以看到内部结构。注意是有namespace的，需要进行处理<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201012172615.png" alt=""><br>把dict传递给writeXliff函数，把译文填写到target中，没有target要先进行创建。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def writeXliff(dict, targetName):</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'读取'</span>+targetName+<span class="string">'xliff文件'</span>)</span><br><span class="line">   <span class="built_in"> lan </span>= languages[targetName]</span><br><span class="line">    xliffPath = os.path.join(xliffRootPath, lan+<span class="string">'.xcloc/Localized Contents/'</span>+lan+<span class="string">'.xliff'</span>)</span><br><span class="line">    <span class="builtin-name">print</span>(xliffPath)</span><br><span class="line">    # 重写nameSpace</span><br><span class="line">    ET.register_namespace(<span class="string">''</span>, <span class="string">'urn:oasis:names:tc:xliff:document:1.2'</span>)</span><br><span class="line">    # 拿到根节点</span><br><span class="line">    tree = ET.parse(xliffPath)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line">    # <span class="builtin-name">print</span>(root.tag)</span><br><span class="line">    count = 0</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> root.findall(<span class="string">'xliffNameSpace:file'</span>, ns):</span><br><span class="line">        #<span class="builtin-name">print</span>(<span class="string">'读取子文件：'</span> + file.attrib[<span class="string">'original'</span>])</span><br><span class="line">        body = file.<span class="builtin-name">find</span>(<span class="string">'xliffNameSpace:body'</span>, ns)</span><br><span class="line">        <span class="keyword">for</span> unit <span class="keyword">in</span> body.findall(<span class="string">'xliffNameSpace:trans-unit'</span>, ns):</span><br><span class="line">            source = unit.<span class="builtin-name">find</span>(<span class="string">'xliffNameSpace:source'</span>, ns)</span><br><span class="line">            #<span class="builtin-name">print</span>(source.text)</span><br><span class="line">            target = unit.<span class="builtin-name">find</span>(<span class="string">'xliffNameSpace:target'</span>, ns)</span><br><span class="line">            # target不存在就创建 在excel中填写译文 否则写入原文</span><br><span class="line">            <span class="keyword">if</span> target is None:</span><br><span class="line">                # 创建target</span><br><span class="line">                <span class="builtin-name">print</span>(<span class="string">"target为空"</span>)</span><br><span class="line">                node = ET.SubElement(unit, <span class="string">"target"</span>)</span><br><span class="line">                <span class="keyword">if</span> source.text <span class="keyword">in</span> dict:</span><br><span class="line">                    node.text = dict[source.text]</span><br><span class="line">                    count += 1</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.text = source.text</span><br><span class="line">                    <span class="builtin-name">print</span>(<span class="string">'填补空白译文'</span>)</span><br><span class="line">                node.tail = <span class="string">'\n\t'</span></span><br><span class="line">                <span class="builtin-name">print</span>(<span class="string">'create success'</span>)</span><br><span class="line">            elif source.text <span class="keyword">in</span> dict:</span><br><span class="line">                target.text = dict[source.text]</span><br><span class="line">                count += 1</span><br><span class="line"></span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'写入完成，共写入 '</span> + str(count) + <span class="string">' 条数据'</span>)</span><br><span class="line">    saveXML(root, xliffPath)</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'finish'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def subElement(root, tag, text):</span><br><span class="line">    ele = ET.SubElement(root, tag)</span><br><span class="line">    ele.text = text</span><br><span class="line"><span class="comment"># 格式优化 不再换行</span></span><br><span class="line">def saveXML(root, filename, <span class="attribute">indent</span>=<span class="string">"\t"</span>, <span class="attribute">newl</span>=<span class="string">""</span>, <span class="attribute">encoding</span>=<span class="string">"utf-8"</span>):</span><br><span class="line">    rawText = ET.tostring(root)</span><br><span class="line">    dom = minidom.parseString(rawText)</span><br><span class="line">    with open(filename, <span class="string">'w'</span>) as f:</span><br><span class="line">        dom.writexml(f, <span class="string">""</span>, indent, newl, encoding)</span><br></pre></td></tr></table></figure><p><code>saveXML</code>是一个自己写的优化XML格式的方法。</p><p>注意存的时候要指定<code>UTF-8</code>编码，要不会有乱码问题。</p><p>Xcode导出和导入Xliff文件也可以使用<code>xocdebuild</code>命令做成自动化。<br>所以可以用shell脚本解决，支持一键导出、录入、导入操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Localization.sh</span></span><br><span class="line"><span class="comment">#  UDictionary</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Created by 李伟灿 on 2021/8/27.</span></span><br><span class="line"><span class="comment">#  Copyright © 2021 com.youdao. All rights reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"=========开始执行========="</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">languages=(<span class="string">"ar"</span></span><br><span class="line">            <span class="comment">#"de"</span></span><br><span class="line">            <span class="string">"en"</span></span><br><span class="line">            <span class="string">"es"</span></span><br><span class="line">            <span class="comment">#"fr"</span></span><br><span class="line">            <span class="string">"id"</span></span><br><span class="line">            <span class="comment">#"it"</span></span><br><span class="line">            <span class="string">"ja"</span></span><br><span class="line">            <span class="comment">#"ko"</span></span><br><span class="line">            <span class="string">"pt"</span></span><br><span class="line">            <span class="comment">#"ru"</span></span><br><span class="line">            <span class="string">"vi-VN"</span></span><br><span class="line">            <span class="string">"zh-Hant"</span></span><br><span class="line">            )</span><br><span class="line">outPath=<span class="string">"<span class="variable">$HOME</span>/Desktop/exportLoaclization"</span></span><br><span class="line">scheme=<span class="string">"UDictionary"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#导出xliff xcode10后为.xcloc格式文件夹</span></span><br><span class="line"><span class="function"><span class="title">exportLocalizations</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"=========开始导出Xliff文件========="</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -e <span class="variable">$outPath</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"=========outPath existed, clean outPath"</span></span><br><span class="line">        rm -rf <span class="variable">$outPath</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    exportLanguageStr=<span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> subLanguage <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;languages[@]&#125;</span>"</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        tmpStr=<span class="string">"-exportLanguage <span class="variable">$subLanguage</span> "</span></span><br><span class="line">        exportLanguageStr=<span class="variable">$exportLanguageStr</span><span class="variable">$tmpStr</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">        <span class="comment">#echo $exportLanguageStr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#xcodebuild -exportLocalizations -project UDictionary.xcodeproj -localizationPath $HOME/Desktop/outData2 -exportLanguage en -exportLanguage ja</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#拼接命令</span></span><br><span class="line">    commandStr=<span class="string">"xcodebuild -exportLocalizations -project <span class="variable">$scheme</span>.xcodeproj -localizationPath <span class="variable">$outPath</span> <span class="variable">$exportLanguageStr</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$commandStr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$commandStr</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"=========Xliff导出完成========="</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">runPython</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"=========执行Python脚本读取Excel========="</span></span><br><span class="line"><span class="comment">#    path=$HOME/Desktop/ExcelToXliff</span></span><br><span class="line"><span class="comment">#    cd $path</span></span><br><span class="line">    chmod +x xliff.py</span><br><span class="line">    python3 xliff.py</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">importLocalizations</span></span>()&#123;</span><br><span class="line">    <span class="keyword">for</span> sub <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;languages[@]&#125;</span>"</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$sub</span></span><br><span class="line"></span><br><span class="line">        tmpStr=<span class="string">"-localizationPath <span class="variable">$outPath</span>/<span class="variable">$sub</span>.xcloc "</span></span><br><span class="line">        commandStr=<span class="string">"xcodebuild -importLocalizations -project <span class="variable">$scheme</span>.xcodeproj <span class="variable">$tmpStr</span>"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$commandStr</span></span><br><span class="line">        <span class="built_in">eval</span> <span class="variable">$commandStr</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"=========Xliff导入完成========="</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#导出xliff</span></span><br><span class="line">exportLocalizations</span><br><span class="line"><span class="comment">#读取excel 写入xliff</span></span><br><span class="line">runPython</span><br><span class="line"><span class="comment">#导入xliff</span></span><br><span class="line">importLocalizations</span><br></pre></td></tr></table></figure><p>把excel放到桌面，在Terminal中运行shell即可</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">chmod +x <span class="module-access"><span class="module"><span class="identifier">Localization</span>.</span></span>sh</span><br><span class="line">./<span class="module-access"><span class="module"><span class="identifier">Localization</span>.</span></span>sh</span><br></pre></td></tr></table></figure><p>附上脚本Git地址：<a href="https://github.com/liweican1992/ExcelToXliff" target="_blank" rel="noopener">https://github.com/liweican1992/ExcelToXliff</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;XLIFF（XML Localisation Interchange File Format，即XML本地化交换文件格式）是一种基于XML的交换格式，旨在标准化本地化过程中在工具之间传递可本地化数据的方式，是CAT工具中常用的一种文件格式。XLIFF由结构化信息标准促进组织（OASIS）于2002年标准化，目前规范为2014年8月5日发布的v2.0&lt;br&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 ——Wiki&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Apple对国际化文案的管理也是基于&lt;code&gt;XLIFF&lt;/code&gt;的，这几年一直负责海外项目。国际化文案翻译和录入是必不可免的。XLIFF是业内的通用做法。&lt;/p&gt;
&lt;p&gt;如果你对XLIFF不了解，可以参考WWDC Session 401:&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2017/401&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Localizing with Xcode 9》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Apple在2018年升级了国际化文案管理方式，从&lt;code&gt;XLIFF&lt;/code&gt;升级到了&lt;code&gt;Localization Catalog&lt;/code&gt;。不过本质上文案管理还是XLIFF。&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201012164605.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体参考WWDC Session404:&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/404/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《New Localization Workflows in Xcode 10》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Localization Catalog&lt;/code&gt; 解决了XLIFF的单一性，可以让翻译人员根据上下文语境更准确的翻译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201012165247.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201012164625.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;一般来说，正确的方法是从Xcode中生成&lt;code&gt;Localization Catalog&lt;/code&gt;，直接把&lt;code&gt;Localization Catalog&lt;/code&gt;给到翻译人员，翻译人员根据storyboard或者图片结合上下文，对文案进行翻译，并且录入到&lt;code&gt;XLIFF&lt;/code&gt;中。然后我们只需要导入到Xcode中就可以了。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SKStorefront—判断用户App Store所在地区</title>
    <link href="http://yoursite.com/2020/06/23/IAP%E2%80%94%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7App-Store%E6%89%80%E5%9C%A8%E5%9C%B0%E5%8C%BA/"/>
    <id>http://yoursite.com/2020/06/23/IAP%E2%80%94%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7App-Store%E6%89%80%E5%9C%A8%E5%9C%B0%E5%8C%BA/</id>
    <published>2020-06-23T12:53:36.000Z</published>
    <updated>2020-06-24T08:29:04.325Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近一年的工作重心都在海外订阅项目上。ROI数据还不错，所以AB测试越做越多。<br>近期要实现一个根据国家和地区来下发不同的SKU的需求。记录一下。</p></blockquote><p>判断用户的国家和地区可以简化为判断用户Apple ID的地区，也就是App Store地区。</p><p>上次和Apple交流，问了这个为问题。告知并没有提供相关API，原因是你App所选的销售地区就是你内购提供的地区，用户可以转区，转区后所订阅的项目也能在新地区提供。</p><p><strong>但是我记得WWDC 2019中，介绍了一个iOS13新增的API，可以监听App Store地区的变化。</strong></p><p>WWDC详见：</p><p><a href="https://developer.apple.com/videos/play/wwdc2019/302/?time=129" target="_blank" rel="noopener">《In-App Purchases and Using Server-to-Server Notifications》</a></p><p>新增的API是<code>SKStorefront</code></p><h2 id="SKStorefront"><a href="#SKStorefront" class="headerlink" title="SKStorefront"></a>SKStorefront</h2><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200623231316.png" alt=""></p><p>官方文档见：<br><a href="https://developer.apple.com/documentation/storekit/skstorefront" target="_blank" rel="noopener">https://developer.apple.com/documentation/storekit/skstorefront</a></p><p>获取地区代码</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="meta">#available(iOS 13.0, *) &#123;</span></span><br><span class="line">    <span class="built_in">print</span>(SKPaymentQueue.<span class="keyword">default</span>().storefront?.countryCode ?? <span class="string">""</span>)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意有可能为nil</p><p>countryCode使用的是ISO 3166-1 Alpha-3代码</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200623232654.png" alt=""></p><p>SKStorefront还可以通过<code>paymentQueueDidChangeStorefront</code>监听App Store地区的变化</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">func payment<span class="constructor">QueueDidChangeStorefront(<span class="params">_</span> <span class="params">queue</span>: SKPaymentQueue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> storefront = queue.storefront &#123;</span><br><span class="line">        <span class="comment">// Refresh the displayed products based on the new storefront.</span></span><br><span class="line">        for product <span class="keyword">in</span> storeProducts &#123;</span><br><span class="line">            <span class="keyword">if</span> should<span class="constructor">Show(<span class="params">product</span>.<span class="params">productIdentifier</span>, <span class="params">in</span>: <span class="params">storefront</span>)</span> &#123;</span><br><span class="line">                <span class="comment">// Display this product in your store UI.</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apple官方文档说SKStorefront随时可能变化，甚至是在购买过程中，因此新增了一个代理方法<code>paymentQueue:shouldContinueTransaction:inStorefront:</code><br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200624111003.png" alt=""><br>此方法的作用是在购买时候发生SKStorefront变化,可以判断要不要继续执行这个Transaction。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().delegate = <span class="keyword">self</span>  <span class="comment">// Set your object as the SKPaymentQueue delegate.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">paymentQueue</span><span class="params">(<span class="number">_</span> paymentQueue: SKPaymentQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                  shouldContinue transaction: SKPaymentTransaction,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">in</span> newStorefront: SKStorefront)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shouldShow(transaction.payment.productIdentifier, <span class="keyword">in</span>: newStorefront)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此地区不支持购买<code>paymentQueue:shouldContinueTransaction:inStorefront:</code>返回<code>false</code>。在Transaction回调中就会收到一个<code>SKErrorStoreProductNotAvailable</code>的Error信息</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">paymentQueue</span><span class="params">(<span class="number">_</span> queue: SKPaymentQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                  updatedTransactions transactions: [SKPaymentTransaction])</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> transaction <span class="keyword">in</span> transactions &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> transactionError = transaction.error <span class="keyword">as</span> <span class="type">NSError?</span>,</span><br><span class="line">            transactionError.domain == <span class="type">SKErrorDomain</span></span><br><span class="line">            &amp;&amp; transactionError.code == <span class="type">SKError</span>.storeProductNotAvailable.rawValue &#123;</span><br><span class="line">            <span class="comment">// Show an alert.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>SKStorefront</code>只支持iOS13+，并不满足我们的需求。因此还要想别的办法。</p><h2 id="通用做法"><a href="#通用做法" class="headerlink" title="通用做法"></a>通用做法</h2><p> 我们的需求是根据国家和地区，下发不同比例的SKU,不存在这个SKU只在这个地区销售的情况。<strong>因为订阅类型的SKU，用户可以在订阅管理里面切换套餐</strong></p><p> 我的做法是从SKU价格处理入手，因为我们是海外项目，在全球销售。所以要要呈现用户所在地区的价格和货币。可以通过<code>NumberFormatter</code>进行转换<br> <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> formatter = <span class="module-access"><span class="module"><span class="identifier">NumberFormatter</span>.</span></span>init<span class="literal">()</span></span><br><span class="line">formatter.formatterBehavior = <span class="module-access"><span class="module"><span class="identifier">NumberFormatter</span>.</span><span class="module"><span class="identifier">Behavior</span>.</span></span>behavior10_4</span><br><span class="line">formatter.numberStyle = <span class="module-access"><span class="module"><span class="identifier">NumberFormatter</span>.</span><span class="module"><span class="identifier">Style</span>.</span></span>currency</span><br><span class="line"><span class="comment">//SKProduct中有priceLocale</span></span><br><span class="line">formatter.locale = product!.priceLocale</span><br><span class="line"><span class="keyword">let</span> price :String = formatter.<span class="built_in">string</span>(from: self.product!.price) ?? <span class="string">"$4.99"</span></span><br></pre></td></tr></table></figure></p><p> 从上述代码可以看到，SKProduct中有个<code>priceLocale</code>属性，赋值给NumberFormatter后可以对价格进行处理。</p><p>priceLocale是Local类型（OC中是NSLocal）</p><p> <img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200624161049.png" alt=""></p><p> Local中有<code>identifier</code>、<code>regionCode</code>等属性。<code>regionCode</code>代表的就是地区，可能为nil，<code>identifier</code>是标识符，是一个字符串。</p><p> 下图是App Store切换到澳大利亚地区，打印的结果<br> <img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200624151437.png" alt=""><br> 下图是美国<br> <img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200624161330.png" alt=""></p><p> 但是regionCode可能为nil，所以要做下判断，当regionCode为nil时候使用identifier，或者跟着业务逻辑调整。</p><p> identifier的格式一般是都是固定的，可以根据@符分割，拿到前面的<code>语言_地区</code>的值。</p><blockquote><p>如何快速切换App Store地区可以看我之前写的这篇文章<a href="http://leevcan.com/2016/03/25/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener">《iOS开发中一些小工具》</a> 使用Switcher这个工具。安装地址：<a href="http://switchr.imagility.io/" target="_blank" rel="noopener">http://switchr.imagility.io/</a></p></blockquote><p>这个办法必须先获取一个可用的<code>SKProduct</code>,并不能在请求<code>SKProduct</code>之前拿到地区。所以还是有一定的局限性。</p><p>我一般是在<code>productsRequest:didReceiveResponse:</code>回调中，拿到一个<code>SKProduct</code>获取到地区后就存起来。有个这个参数也可以在埋点上报中用到，标明用户的App Store地区。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近一年的工作重心都在海外订阅项目上。ROI数据还不错，所以AB测试越做越多。&lt;br&gt;近期要实现一个根据国家和地区来下发不同的SKU的需求。记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;判断用户的国家和地区可以简化为判断用户Apple ID
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从源码分析Swift多线程—DispatchGroup</title>
    <link href="http://yoursite.com/2020/05/30/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Swift%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94DispatchGroup/"/>
    <id>http://yoursite.com/2020/05/30/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Swift%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94DispatchGroup/</id>
    <published>2020-05-30T14:18:46.000Z</published>
    <updated>2020-06-22T06:51:55.969Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文从源码分析GCD中的DispatchGroup是怎么调度的，notify的背后是如何实现的。如果你对Swift中GCD如何使用不太了解。可以参考<a href="http://leevcan.com/2020/05/22/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Swift%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">《详解Swift多线程》</a></p></blockquote><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>以下代码是DispatchGroup的常用使用场景</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">        let g1 = DispatchGroup.init()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直接输入notify null</span></span><br><span class="line">        g1.notify(<span class="string">queue:</span> DispatchQueue.global()) &#123;</span><br><span class="line">            print(<span class="string">"notify null"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//A B 并发 A B 完成后开启C任务</span></span><br><span class="line"></span><br><span class="line">        g1.enter()</span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0.</span>.<span class="number">.3</span>&#123;</span><br><span class="line">              print(<span class="string">"task A: \(Thread.current)"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          g1.leave()</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        g1.enter()</span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0.</span>.<span class="number">.3</span> &#123;</span><br><span class="line">                print(<span class="string">"task B: \(Thread.current)"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="comment">//sleep(UInt32(3.5))</span></span><br><span class="line">          g1.leave()</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      g1.notify(<span class="string">queue:</span> DispatchQueue.global()) &#123;</span><br><span class="line">            print(<span class="string">"notify A&amp;B"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      g1.notify(<span class="string">queue:</span> DispatchQueue.global()) &#123;</span><br><span class="line">            print(<span class="string">"notify A&amp;B again"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//打印结果</span></span><br><span class="line">notify <span class="literal">null</span></span><br><span class="line">task <span class="string">A:</span> &lt;<span class="string">NSThread:</span> <span class="number">0x600002be85c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">task <span class="string">B:</span> &lt;<span class="string">NSThread:</span> <span class="number">0x600002bc5300</span>&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">task <span class="string">A:</span> &lt;<span class="string">NSThread:</span> <span class="number">0x600002be85c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">task <span class="string">B:</span> &lt;<span class="string">NSThread:</span> <span class="number">0x600002bc5300</span>&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">task <span class="string">A:</span> &lt;<span class="string">NSThread:</span> <span class="number">0x600002be85c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">task <span class="string">A:</span> &lt;<span class="string">NSThread:</span> <span class="number">0x600002be85c0</span>&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">task <span class="string">B:</span> &lt;<span class="string">NSThread:</span> <span class="number">0x600002bc5300</span>&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">task <span class="string">B:</span> &lt;<span class="string">NSThread:</span> <span class="number">0x600002bc5300</span>&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span><br><span class="line">notify A&amp;B</span><br><span class="line">notify A&amp;B again</span><br></pre></td></tr></table></figure><p>由以上代码结果可以得知，notity之前没有调用enter()和levae()会直接被调用。<br>如果在notity之前调用了enter()和leave()。notify会在最后一个leave()调用后才会回调。</p><p>wait()的使用</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">g1</span> = DispatchGroup.init()</span><br><span class="line">        </span><br><span class="line">  <span class="built_in">g1</span>.enter()</span><br><span class="line">  DispatchQueue.global().async &#123;</span><br><span class="line">      <span class="keyword">for</span> <span class="symbol">_</span> <span class="keyword">in</span> <span class="number">0</span>...<span class="number">3</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"task A: \(Thread.current)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">g1</span>.leave()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g1</span>.enter()</span><br><span class="line">  DispatchQueue.global().async &#123;</span><br><span class="line">      <span class="keyword">for</span> <span class="symbol">_</span> <span class="keyword">in</span> <span class="number">0</span>...<span class="number">3</span> &#123;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">"task B: \(Thread.current)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">      sleep(UInt32(<span class="number">3.5</span>))</span><br><span class="line">    <span class="built_in">g1</span>.leave()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">let</span> result = <span class="built_in">g1</span>.wait(timeout: .now() + <span class="number">3</span>)</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">  switch result &#123;</span><br><span class="line">  case .success:</span><br><span class="line">      <span class="built_in">g1</span>.notify(queue: DispatchQueue.global()) &#123;</span><br><span class="line">          DispatchQueue.global().async &#123;</span><br><span class="line">              <span class="keyword">for</span> <span class="symbol">_</span> <span class="keyword">in</span> <span class="number">0</span>...<span class="number">3</span> &#123;</span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">"task D: \(Thread.current)"</span>)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  case .timedOut:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"timedOut"</span>)</span><br><span class="line">      <span class="built_in">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //打印结果</span><br><span class="line">  timedOut</span><br></pre></td></tr></table></figure><h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><p>Swift使用的GCD是桥接OC的源码。所以底层还是libdispatch。</p><p>源码可以去opensource下载：<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/libdispatch/</a></p><p>也可以去github上Apple官方仓库去下载：<a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank" rel="noopener">https://github.com/apple/swift-corelibs-libdispatch</a></p><blockquote><p>要注意Apple的源码是一直在迭代升级的。封装也是越来越深，在opensource上可以看到很多版本的源码。写这篇文章时候最新版本为1173.40.5版本。本文分析基于931.60.2版本。网速很多资料的源码都是很老的187.9版本之前。内部实现变动很大。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601114808.png" alt=""></p><p>下载源码后，可以在semaphore.c中找到DispatchGroup的实现。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601114842.png" alt=""></p><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>先来看看dispatch_group_create的实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//libdispatch-913.60.2.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dispatch_group_t</span></span><br><span class="line">dispatch_group_create(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _dispatch_group_create_with_count(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//而网上的资料一般都比较老</span></span><br><span class="line"><span class="comment">//一般是 libdispatch-187.9.tar.gz 或者之前</span></span><br><span class="line"><span class="comment">//这是旧的代码 可以看到传入的值是LONG_MAX</span></span><br><span class="line"><span class="keyword">dispatch_group_t</span></span><br><span class="line">dispatch_group_create(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">dispatch_group_t</span>)dispatch_semaphore_create(LONG_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_dispatch_group_create_with_count的实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_group_t</span></span><br><span class="line">_dispatch_group_create_with_count(<span class="keyword">long</span> count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//dispatch_group_t就是dispatchGroup</span></span><br><span class="line"><span class="comment">//dispatch_group_t本质上就是dispatch_group_s 详见下方</span></span><br><span class="line"><span class="keyword">dispatch_group_t</span> dg = (<span class="keyword">dispatch_group_t</span>)_dispatch_object_alloc(</span><br><span class="line">DISPATCH_VTABLE(group), <span class="keyword">sizeof</span>(struct dispatch_group_s));</span><br><span class="line"><span class="comment">//把count的值存进去结构体</span></span><br><span class="line">_dispatch_semaphore_class_init(count, dg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 如果有值 就执行os_atomic_store2o</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">_dispatch_group_create_and_enter 就是传入1进来</span></span><br><span class="line"><span class="comment">dispatch_group_t</span></span><br><span class="line"><span class="comment">    _dispatch_group_create_and_enter(void)&#123;</span></span><br><span class="line"><span class="comment">return _dispatch_group_create_with_count(1);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line">os_atomic_store2o(dg, do_ref_cnt, <span class="number">1</span>, relaxed); <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">#define os_atomic_store2o(p, f, v, m) \</span></span><br><span class="line"><span class="comment">注意 &amp;(p)-&gt;f</span></span><br><span class="line"><span class="comment">等于把1存进dg.do_ref_cnt</span></span><br><span class="line"><span class="comment">os_atomic_store(&amp;(p)-&gt;f, (v), m)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一个一个来分析</p><p>通过搜索发现dispatch_group_t本质上就是dispatch_group_s</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601114914.png" alt=""></p><p>dispatch_group_s是一个结构体</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> &#123;</span></span><br><span class="line">DISPATCH_SEMAPHORE_HEADER(group, dg);</span><br><span class="line">    <span class="comment">//看名字知道和wait方法有关</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">volatile</span> dg_waiters;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//dispatch_continuation_s可以自行搜索 最后是个dispatch_object_s</span></span><br><span class="line"><span class="comment">//这里可以理解为存储一个链表的 链表头和尾。看参数名知道和notify有关</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dg_notify_head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dg_notify_tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，creat方法创建了一个dispatch_group_t（也是dispatch_group_s）出来，默认传进来的count是0，并且把count通过dispatch_semaphore_class_init(count, dg)存了起来。</p><p>dispatch_semaphore_class_init</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//_dispatch_semaphore_class_init(count, dg);</span></span><br><span class="line">static void</span><br><span class="line"><span class="constructor">_dispatch_semaphore_class_init(<span class="params">long</span> <span class="params">value</span>, <span class="params">dispatch_semaphore_class_t</span> <span class="params">dsemau</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//dsemau就是dg 本质就是把传递进来的count存起来</span></span><br><span class="line"><span class="keyword">struct</span> dispatch_semaphore_header_s *dsema = dsemau._dsema_hdr;</span><br><span class="line"></span><br><span class="line">dsema-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">dsema-&gt;do_targetq = <span class="constructor">_dispatch_get_root_queue(DISPATCH_QOS_DEFAULT, <span class="params">false</span>)</span>;</span><br><span class="line"><span class="comment">//value就是传进来的count</span></span><br><span class="line">dsema-&gt;dsema_value = value;</span><br><span class="line"><span class="constructor">_dispatch_sema4_init(&amp;<span class="params">dsema</span>-&gt;<span class="params">dsema_sema</span>, <span class="params">_DSEMA4_POLICY_FIFO</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok,通过creat方法我们知道我们创建了一个dispatch_group_s出来，并且把0存了起来。知道dispatch_group_s中有一个类似链表的头和尾，看参数名知道和notify有关。</p><h4 id="enter"><a href="#enter" class="headerlink" title="enter()"></a>enter()</h4><p>enter() 本质上调用dispatch_group_enter()</p><p>dispatch_group_enter</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//os_atomic_inc_orig2o是宏定义，可以一直点进去看。本质上就是把dg的dg_value做+1操作。</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">value</span> = os_atomic_inc_orig2o(dg, dg_value, acquire);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (slowpath((unsigned <span class="keyword">long</span>)<span class="keyword">value</span> &gt;= (unsigned <span class="keyword">long</span>)LONG_MAX)) &#123;</span><br><span class="line">DISPATCH_CLIENT_CRASH(<span class="keyword">value</span>,</span><br><span class="line"><span class="string">"Too many nested calls to dispatch_group_enter()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">value</span> == <span class="number">0</span>) &#123;</span><br><span class="line">_dispatch_retain(dg); <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码上看enter没做其余的操作，就是把dg的dg_value做+1操作。如果dg_value值过大就会crash。</p><h4 id="leave"><a href="#leave" class="headerlink" title="leave()"></a>leave()</h4><p>那么同理我们可以想到leave()应该是做-1操作。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//dg_value -1</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">value</span> = os_atomic_dec2o(dg, dg_value, release);</span><br><span class="line"><span class="keyword">if</span> (slowpath(<span class="keyword">value</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">//当value==0 执行_dispatch_group_wake</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span>)_dispatch_group_wake(dg, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不成对出现 crash</span></span><br><span class="line"><span class="keyword">if</span> (slowpath(<span class="keyword">value</span> &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">DISPATCH_CLIENT_CRASH(<span class="keyword">value</span>,</span><br><span class="line"><span class="string">"Unbalanced call to dispatch_group_leave()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码得知，leave的核心逻辑是判断value==0时候执行<strong>_dispatch_group_wake</strong>。同时当levae次数比enter多时候，value&lt;0会crash</p><p>同时真正执行的逻辑应该在_dispatch_group_wake中</p><h4 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_group_notify(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line"><span class="keyword">dispatch_continuation_t</span> dsn)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把目标队列保存到dc_data中</span></span><br><span class="line">dsn-&gt;dc_data = dq;</span><br><span class="line">dsn-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">_dispatch_retain(dq);</span><br><span class="line"><span class="keyword">if</span> (os_mpsc_push_update_tail(dg, dg_notify, dsn, do_next)) &#123;</span><br><span class="line">_dispatch_retain(dg);</span><br><span class="line">os_atomic_store2o(dg, dg_notify_head, dsn, ordered);</span><br><span class="line"><span class="comment">// seq_cst with atomic store to notify_head &lt;rdar://problem/11750916&gt;</span></span><br><span class="line"><span class="comment">//判断dg.dg_value是否为0 </span></span><br><span class="line"><span class="keyword">if</span> (os_atomic_load2o(dg, dg_value, ordered) == <span class="number">0</span>) &#123;</span><br><span class="line">_dispatch_group_wake(dg, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，核心逻辑还是dg.davalue为0的话，就直接调用_dispatch_group_wake。所以可以解释为什么notify调用之前没有enter和leave为什么会直接被回调。<strong>因为没有enter和leave，dg_value为0，直接调用_dispatch_group_wake</strong></p><h4 id="dispatch-group-wake"><a href="#dispatch-group-wake" class="headerlink" title="_dispatch_group_wake()"></a>_dispatch_group_wake()</h4><p>可以说DispatchGroup的核心逻辑就在_dispatch_group_wake方法中</p><p>先来看看源码实现</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line">static long</span><br><span class="line"><span class="constructor">_dispatch_group_wake(<span class="params">dispatch_group_t</span> <span class="params">dg</span>, <span class="params">bool</span> <span class="params">needs_release</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">dispatch_continuation_t next, head, tail = NULL;</span><br><span class="line">long rval;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cannot use os_mpsc_capture_snapshot() because we can have concurrent</span></span><br><span class="line"><span class="comment">// _dispatch_group_wake() calls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch_group_s 中dg_notify_head</span></span><br><span class="line">head = os<span class="constructor">_atomic_xchg2o(<span class="params">dg</span>, <span class="params">dg_notify_head</span>, NULL, <span class="params">relaxed</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line"><span class="comment">// snapshot before anything is notified/woken &lt;rdar://problem/8554546&gt;</span></span><br><span class="line">tail = os<span class="constructor">_atomic_xchg2o(<span class="params">dg</span>, <span class="params">dg_notify_tail</span>, NULL, <span class="params">release</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">rval = (long)os<span class="constructor">_atomic_xchg2o(<span class="params">dg</span>, <span class="params">dg_waiters</span>, 0, <span class="params">relaxed</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (rval) &#123;</span><br><span class="line"><span class="comment">// wake group waiters</span></span><br><span class="line"><span class="constructor">_dispatch_sema4_create(&amp;<span class="params">dg</span>-&gt;<span class="params">dg_sema</span>, <span class="params">_DSEMA4_POLICY_FIFO</span>)</span>;</span><br><span class="line"><span class="constructor">_dispatch_sema4_signal(&amp;<span class="params">dg</span>-&gt;<span class="params">dg_sema</span>, <span class="params">rval</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">uint16_t refs = needs_release ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line"><span class="comment">// async group notify blocks</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">next = os<span class="constructor">_mpsc_pop_snapshot_head(<span class="params">head</span>, <span class="params">tail</span>, <span class="params">do_next</span>)</span>;</span><br><span class="line">dispatch_queue_t dsn_queue = (dispatch_queue_t)head-&gt;dc_data;</span><br><span class="line"><span class="comment">//head就是notify的block 在目标队列dsn_queue上运行</span></span><br><span class="line"><span class="constructor">_dispatch_continuation_async(<span class="params">dsn_queue</span>, <span class="params">head</span>)</span>;</span><br><span class="line"><span class="constructor">_dispatch_release(<span class="params">dsn_queue</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> ((head = next));</span><br><span class="line">refs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (refs) <span class="constructor">_dispatch_release_n(<span class="params">dg</span>, <span class="params">refs</span>)</span>;</span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否还记得前面提到的dispatch_group_s中的链表头和尾？</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">head = os<span class="constructor">_atomic_xchg2o(<span class="params">dg</span>, <span class="params">dg_notify_head</span>, NULL, <span class="params">relaxed</span>)</span>;</span><br></pre></td></tr></table></figure><p>这里取出dispatch_group_s中的链表头，如果有链表头再取出链表尾。</p><p>核心逻辑在这个do while循环中</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line"><span class="comment">// async group notify blocks</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">next = os<span class="constructor">_mpsc_pop_snapshot_head(<span class="params">head</span>, <span class="params">tail</span>, <span class="params">do_next</span>)</span>;</span><br><span class="line">dispatch_queue_t dsn_queue = (dispatch_queue_t)head-&gt;dc_data;</span><br><span class="line"><span class="comment">//head就是notify的block 在目标队列dsn_queue上运行</span></span><br><span class="line"><span class="constructor">_dispatch_continuation_async(<span class="params">dsn_queue</span>, <span class="params">head</span>)</span>;</span><br><span class="line"><span class="constructor">_dispatch_release(<span class="params">dsn_queue</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> ((head = next));</span><br><span class="line">refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>head-&gt;dc_data</code>拿到目标队列，然后通过<code>_dispatch_continuation_async(dsn_queue, head)</code>将head运行在目标队列上。</p><p>那head是什么就一目了然了。<code>这个队列中存储的是notify回调的block</code></p><p>再来看看dispatch_group_s的定义</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> &#123;</span></span><br><span class="line">DISPATCH_SEMAPHORE_HEADER(group, dg);</span><br><span class="line">    <span class="comment">//看名字知道和wait方法有关</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">volatile</span> dg_waiters;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//这里就是把所有notify的回调block存进链表里，然后拿到头结点和尾结点。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dg_notify_head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dg_notify_tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>DispatchGroup 在创建时候会建立一个链表，来存储notify的block回调。</p><p>判断notify执行的依据就是dg_value是否为0</p><p>当不调用enter和leave时候，dg_value=0，notify的回调会立即执行，并且有多个notify会按照顺序依次调用。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g1 = <span class="module-access"><span class="module"><span class="identifier">DispatchGroup</span>.</span></span>init<span class="literal">()</span></span><br><span class="line">        </span><br><span class="line">g1.notify(queue: <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global<span class="literal">()</span>) &#123;</span><br><span class="line">print(<span class="string">"notify null"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g1.notify(queue: <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global<span class="literal">()</span>) &#123;</span><br><span class="line">print(<span class="string">"notify null2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接输入notify null,notify null2</span></span><br></pre></td></tr></table></figure><p>当有enter时候dg_value+1。leave时候-1。<br>当最后一个leave执行后，dg_value==0。去循环链表执行notify的回调</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">let</span> <span class="built_in">g1</span> = DispatchGroup.init()</span><br><span class="line">  </span><br><span class="line">        //A B 并发 A B 完成后开启C任务</span><br><span class="line"></span><br><span class="line">        <span class="built_in">g1</span>.enter()</span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="symbol">_</span> <span class="keyword">in</span> <span class="number">0</span>...<span class="number">3</span>&#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">"task A: \(Thread.current)"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">g1</span>.leave()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">g1</span>.enter()</span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="symbol">_</span> <span class="keyword">in</span> <span class="number">0</span>...<span class="number">3</span>&#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">"task B: \(Thread.current)"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">g1</span>.leave()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">g1</span>.notify(queue: DispatchQueue.global()) &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"notify A&amp;B"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码也得知，enter和leave必须成对出现。</p><p>当enter多的时候，dg_value永远大于0，notify不会被执行。</p><p>当leave多的时候，dg_value小于0，造成Crash</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>Apple的API封装的很好，其中的一些设计模式也值得我们学习。</p><p>GCD的执行效率特别高，在读源码中发现if判断用了很多<code>slowpath</code> <code>fastpath</code></p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//dg_value -1</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">value</span> = os_atomic_dec2o(dg, dg_value, release);</span><br><span class="line"><span class="keyword">if</span> (slowpath(<span class="keyword">value</span> == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span>)_dispatch_group_wake(dg, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不成对出现 crash</span></span><br><span class="line"><span class="keyword">if</span> (slowpath(<span class="keyword">value</span> &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">DISPATCH_CLIENT_CRASH(<span class="keyword">value</span>,</span><br><span class="line"><span class="string">"Unbalanced call to dispatch_group_leave()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个会再另起一篇博客来研究。</p><p>关于DispatchGroup 的<code>wait()</code>实现就不再分析了。大家可以自行下载源码来研究下。</p><p>带注释的源码详见Github:</p><p><a href="https://github.com/liweican1992/libdispatch" target="_blank" rel="noopener">https://github.com/liweican1992/libdispatch</a></p><p><a href="https://github.com/liweican1992/swift-corelibs-foundation" target="_blank" rel="noopener">https://github.com/liweican1992/swift-corelibs-foundation</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文从源码分析GCD中的DispatchGroup是怎么调度的，notify的背后是如何实现的。如果你对Swift中GCD如何使用不太了解。可以参考&lt;a href=&quot;http://leevcan.com/2020/05/22/%E4%BB%8E%E
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>详解Swift多线程</title>
    <link href="http://yoursite.com/2020/05/22/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Swift%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/05/22/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Swift%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-05-22T09:18:00.000Z</published>
    <updated>2020-06-01T04:11:42.566Z</updated>
    
    <content type="html"><![CDATA[<p>Swift终于在5.x版本变得稳定，先来看看Swift5.1中的GCD如何使用</p><ul><li><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4></li></ul><h6 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h6><p>串行队列一般只分配一个线程，队列如果有任务执行是不允许插队。<br>串行队列中执行任务的线程不允许被当前队列中的任务阻塞（死锁），但是能被其他对列阻塞</p><p>默认创建的是串行队列</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">let<span class="built_in"> queue </span>= DispatchQueue(label: <span class="string">"com.youdao.queueName"</span>)</span><br></pre></td></tr></table></figure><p>主线程就是串行队列</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>main</span><br></pre></td></tr></table></figure><p>常见的主线程死锁</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main Threed</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">DispatchQueue<span class="selector-class">.main</span><span class="selector-class">.sync</span> &#123;</span><br><span class="line">     print(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><h6 id="（并行队列）-并发队列"><a href="#（并行队列）-并发队列" class="headerlink" title="（并行队列）  并发队列"></a><del>（并行队列）</del>  并发队列</h6><p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121052.png" alt=""><br>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121114.png" alt=""></p><p>Erlang 之父 Joe Armstrong 的解释</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121133.png" alt=""></p><p>创建并发队列</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> taskD_queue = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>init(label: <span class="string">"com.youdao.concurrent"</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure><p>系统并发队列</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> globalQueue = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global<span class="literal">()</span></span><br></pre></td></tr></table></figure><h6 id="更多参数"><a href="#更多参数" class="headerlink" title="更多参数"></a>更多参数</h6><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> convenience init(<span class="string">label:</span> String, <span class="string">qos:</span> DispatchQoS = .unspecified, <span class="string">attributes:</span> DispatchQueue.Attributes = [],</span><br><span class="line"><span class="string">autoreleaseFrequency:</span> DispatchQueue.AutoreleaseFrequency = .inherit, <span class="string">target:</span> DispatchQueue? = nil)</span><br></pre></td></tr></table></figure><p><strong>qos</strong></p><p>Quality of Service(服务质量)<br>队列执行有优先级，优先级由高到低</p><ul><li>userInteractive： 用户交互任务（例如动画，事件处理或更新应用程序的用户界面）的服务</li><li>userInitiated：用户发起的动作需要立即得到结果 如打开文档，显示电子邮件</li><li>default：默认的</li><li>utility:用户不主动关注的，一些耗时操作。下载或者导入数据,utility任务一般有一个进度条让用户能看到</li><li>background：最低优先级 后台运行。建立索引 清理文件</li></ul><p>默认值为 <strong>default</strong></p><p>还有一个特殊的<strong>unspecified</strong></p><blockquote><p>它表示当前没有QoS信息，系统应该根据环境自动推断QoS信息。如果使用遗弃的API，线程有可能会脱离QoS，这个时候，线程就是unspecified QoS类别的</p></blockquote><p>因此系统并发队列有6个</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> globalQueue1 = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global(qos: .userInteractive)</span><br><span class="line"><span class="keyword">let</span> globalQueue2 = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global(qos: .userInitiated)</span><br><span class="line"><span class="keyword">let</span> globalQueue5 = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global<span class="literal">()</span> <span class="comment">//qos default </span></span><br><span class="line"><span class="keyword">let</span> globalQueue3 = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global(qos: .utility)</span><br><span class="line"><span class="keyword">let</span> globalQueue4 = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global(qos: .background)</span><br><span class="line"><span class="comment">//❌  不存在这种</span></span><br><span class="line"><span class="keyword">let</span> globalQueue4 = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global(qos: .unspecified)</span><br></pre></td></tr></table></figure><blockquote><p>要注意，在Low Power Mode下，qos为background的队列将被暂停</p></blockquote><p><strong>attributes</strong></p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Set</span></span><br><span class="line"><span class="keyword">public</span> struct <span class="string">Attributes :</span> OptionSet</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> let <span class="string">concurrent:</span> DispatchQueue.Attributes</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(OSX <span class="number">10.12</span>, iOS <span class="number">10.0</span>, tvOS <span class="number">10.0</span>, watchOS <span class="number">3.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> let <span class="string">initiallyInactive:</span> DispatchQueue.Attributes</span><br></pre></td></tr></table></figure><ul><li>concurrent：标记为并发队列</li><li>initiallyInactive：标识队列中的任务需要手动触发，由队列activate()方法触发。未标记initiallyInactive的队列会自动触发任务</li></ul><p>不标明此参数，默认是串行队列。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行队列</span></span><br><span class="line"><span class="keyword">let</span> task_queue_ser = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>init(label: <span class="string">"com.youdao.queue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发队列</span></span><br><span class="line"><span class="keyword">let</span> task_queue_concurrent = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>init(label: <span class="string">"com.youdao.queue"</span>, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动触发</span></span><br><span class="line"><span class="keyword">let</span> task_queue_initial = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>init(label: <span class="string">"com.youdao.queue"</span>, attributes: .initiallyInactive)</span><br><span class="line">task_queue_initial.active<span class="literal">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手动触发的并发队列</span></span><br><span class="line"><span class="keyword">let</span> task_queue_combine = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>init(label: <span class="string">"com.youdao.queue"</span>, attributes: <span class="literal">[.<span class="identifier">concurrent</span>, .<span class="identifier">initiallyInactive</span>]</span>)</span><br><span class="line">task_queue_combine.active<span class="literal">()</span></span><br></pre></td></tr></table></figure><p><strong>autoreleaseFrequency</strong></p><p>autoreleaseFrequency是枚举，标明autoreleasepool的释放频率</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">enum</span> AutoreleaseFrequency &#123;</span><br><span class="line">        <span class="comment">//继承目标队列</span></span><br><span class="line">        <span class="keyword">case</span> inherit</span><br><span class="line">        <span class="comment">//跟随每个任务的执行周期进行自动创建和释放</span></span><br><span class="line">        @available(OSX <span class="number">10.12</span>, iOS <span class="number">10.0</span>, tvOS <span class="number">10.0</span>, watchOS <span class="number">3.0</span>, *)</span><br><span class="line">        <span class="keyword">case</span> workItem</span><br><span class="line">        <span class="comment">//不创建autoreleasepool</span></span><br><span class="line">        @available(OSX <span class="number">10.12</span>, iOS <span class="number">10.0</span>, tvOS <span class="number">10.0</span>, watchOS <span class="number">3.0</span>, *)</span><br><span class="line">        <span class="keyword">case</span> never</span><br><span class="line">        </span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己创建的队列，默认值是 .inherit</p><p>系统定义的全局队列，此属性是 .never</p><p>如果任务中需要大量创建对象，可以设置为.never，然后手动创建autoreleasepool</p><p><strong>target</strong></p><p>设置一个队列的目标队列，讲当前队列中的任务放到目标队列中取执行。目标队列最终约束了队列任务的优先级。</p><p>所有手动创建的队列，target最终都指向了系统自带的队列。主队列或者全局并发队列。</p><blockquote><p>为什么不直接加到系统队列，而是要自定义队列呢？这样的好处是可以将任务分组管理。如单独阻塞某个队列中的任务，而不是阻塞系统队列中的全部任务。如果阻塞了系统队列，所有指向它的原队列也就被阻塞。</p></blockquote><p>设置target可以在DispatchQueue初始化时候指定。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">let task_queue = DispatchQueue.init(<span class="string">label:</span> <span class="string">"abc"</span>, <span class="string">qos:</span> .<span class="keyword">default</span>, <span class="string">attributes:</span> [.concurrent], <span class="string">autoreleaseFrequency:</span> .workItem, <span class="string">target:</span> DispatchQueue.global())</span><br></pre></td></tr></table></figure><p>也可以指定attributes为.initiallyInactive。手动触发前使用setTarget更改指定的target</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> task_queue = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>init(label: <span class="string">"abc"</span>, qos: .default, attributes: <span class="literal">[.<span class="identifier">initiallyInactive</span>, .<span class="identifier">concurrent</span>]</span>, autoreleaseFrequency: .workItem, target: <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global<span class="literal">()</span>)</span><br><span class="line">        </span><br><span class="line">task_queue.set<span class="constructor">Target(<span class="params">queue</span>: DispatchQueue.<span class="params">global</span>(<span class="params">qos</span>: .<span class="params">background</span>)</span>)</span><br></pre></td></tr></table></figure><p>可以思考下，下方代码会输出什么。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> task_queue = <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>init(label: <span class="string">"abc"</span>, qos: .default, attributes: <span class="literal">[.<span class="identifier">initiallyInactive</span>, .<span class="identifier">concurrent</span>]</span>, autoreleaseFrequency: .workItem, target: <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>main)</span><br><span class="line">        </span><br><span class="line">task_queue.async &#123;</span><br><span class="line">    for k <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="number">10</span> &#123;</span><br><span class="line">        print( <span class="string">"A"</span> + <span class="constructor">String(<span class="params">k</span>)</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task_queue.async &#123;</span><br><span class="line">    for k <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="number">10</span> &#123;</span><br><span class="line">        print( <span class="string">"B"</span> + <span class="constructor">String(<span class="params">k</span>)</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">task_queue.activate<span class="literal">()</span></span><br></pre></td></tr></table></figure><p>Group</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift终于在5.x版本变得稳定，先来看看Swift5.1中的GCD如何使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;串行队列&quot;&gt;&lt;a href=&quot;#串行队列&quot; class=&quot;headerlink&quot; title=&quot;串行队列&quot;&gt;&lt;/a&gt;串行队列&lt;/h6&gt;&lt;p&gt;串行队列一般只分配一个线程，队列如果有任务执行是不允许插队。&lt;br&gt;串行队列中执行任务的线程不允许被当前队列中的任务阻塞（死锁），但是能被其他对列阻塞&lt;/p&gt;
&lt;p&gt;默认创建的是串行队列&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let&lt;span class=&quot;built_in&quot;&gt; queue &lt;/span&gt;= DispatchQueue(label: &lt;span class=&quot;string&quot;&gt;&quot;com.youdao.queueName&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;主线程就是串行队列&lt;/p&gt;
&lt;figure class=&quot;highlight reasonml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;module-access&quot;&gt;&lt;span class=&quot;module&quot;&gt;&lt;span class=&quot;identifier&quot;&gt;DispatchQueue&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;main&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;常见的主线程死锁&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//main Threed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DispatchQueue&lt;span class=&quot;selector-class&quot;&gt;.main&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.sync&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     print(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>转移简书到Github</title>
    <link href="http://yoursite.com/2020/05/15/%E8%BD%AC%E7%A7%BB%E7%AE%80%E4%B9%A6%E5%88%B0Github/"/>
    <id>http://yoursite.com/2020/05/15/%E8%BD%AC%E7%A7%BB%E7%AE%80%E4%B9%A6%E5%88%B0Github/</id>
    <published>2020-05-15T10:40:00.000Z</published>
    <updated>2020-06-24T16:42:51.514Z</updated>
    
    <content type="html"><![CDATA[<p>今天简书账号莫名其妙的被封了，加上之前封了好几篇技术文章。终于使我下定决心干掉简书。</p><p>用简书已经有5年了，写了20多篇博客，收获了100+的粉丝。</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142307.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142320.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142351.png" alt=""></p><p>甚至还收到了几块钱的打赏<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200625003458.png" alt=""></p><p>现在规则越来越严格，之前写的很多文章都被转成只有自己可见了。<br>这次被封应该是文章中添加了参考链接。</p><p>以后文章都会更新在github博客上，我也会把简书的旧文章转移过来，刚好清理一波质量较差的文章。</p><p>博客地址为：<a href="http://leevcan.com/" target="_blank" rel="noopener">http://leevcan.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天简书账号莫名其妙的被封了，加上之前封了好几篇技术文章。终于使我下定决心干掉简书。&lt;/p&gt;
&lt;p&gt;用简书已经有5年了，写了20多篇博客，收获了100+的粉丝。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Facebook iOS SDK 造成大面积崩溃</title>
    <link href="http://yoursite.com/2020/05/08/Facebook-iOS-SDK-%E9%80%A0%E6%88%90%E5%A4%A7%E9%9D%A2%E7%A7%AF%E5%B4%A9%E6%BA%83/"/>
    <id>http://yoursite.com/2020/05/08/Facebook-iOS-SDK-%E9%80%A0%E6%88%90%E5%A4%A7%E9%9D%A2%E7%A7%AF%E5%B4%A9%E6%BA%83/</id>
    <published>2020-05-08T06:28:00.000Z</published>
    <updated>2020-07-13T08:57:34.580Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>update:2020.07.10 FaceBook SDK 又双叒叕崩溃了。这次貌似比上次还严重。通过这两次大范围崩溃，充分暴露了Facebook内部流程出现了很大的问题。这次问题的原因又是SDK远程下方配置文件造成的。</p></blockquote><p>详见:</p><p><a href="https://github.com/facebook/facebook-ios-sdk/issues/1427" target="_blank" rel="noopener">https://github.com/facebook/facebook-ios-sdk/issues/1427</a><br><a href="https://developers.facebook.com/support/bugs/329763701368293/" target="_blank" rel="noopener">https://developers.facebook.com/support/bugs/329763701368293/</a></p><hr><p>一大早就接到警告，App崩溃率直线上升。赶紧定位错误，发现是崩在了Facebook SDK上面。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142944.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143021.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143043.png" alt=""></p><p>因为我们是海外项目。受影响最大，所以最先接到警告。<br>看了下，应该是Facebook SDK初始化时候就crash了，同时也有用户反馈App一启动就闪退。</p><a id="more"></a><p>但是今天再测试（2020.05.08 北京时间），无法复现问题，看来已经被修复了。<br>去Github上围观了一下，影响范围可谓是巨大</p><blockquote><p>详见issue:<br><a href="https://github.com/facebook/facebook-ios-sdk/issues/1373" target="_blank" rel="noopener">https://github.com/facebook/facebook-ios-sdk/issues/1373</a><br><a href="https://github.com/facebook/facebook-ios-sdk/issues/1374" target="_blank" rel="noopener">https://github.com/facebook/facebook-ios-sdk/issues/1374</a></p></blockquote><p>官方也承认是SDK的问题。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143102.png" alt=""></p><p>有人猜测是将Bool值放入了字典中<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143112.png" alt=""></p><p>问题已经解决，但是教训还是比较深刻的。任何改动上线前，一定要进行灰度测试。</p><p>只是可惜了我们App的99.9%的稳定性 :(<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143129.png" alt=""><br>参考链接 ：</p><p><a href="https://www.theverge.com/2020/5/7/21250689/facebook-sdk-bug-ios-app-crash-apple-spotify-venmo-tiktok-tinder" target="_blank" rel="noopener">Why a small Facebook bug wreaked havoc on some of the most popular iOS apps</a><br><a href="https://www.thepaper.cn/newsDetail_forward_7301372" target="_blank" rel="noopener">小扎的Facebook，搞炸了几十万个iOS应用程序</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;update:2020.07.10 FaceBook SDK 又双叒叕崩溃了。这次貌似比上次还严重。通过这两次大范围崩溃，充分暴露了Facebook内部流程出现了很大的问题。这次问题的原因又是SDK远程下方配置文件造成的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详见:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/facebook-ios-sdk/issues/1427&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/facebook/facebook-ios-sdk/issues/1427&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developers.facebook.com/support/bugs/329763701368293/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developers.facebook.com/support/bugs/329763701368293/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一大早就接到警告，App崩溃率直线上升。赶紧定位错误，发现是崩在了Facebook SDK上面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142944.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143021.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143043.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为我们是海外项目。受影响最大，所以最先接到警告。&lt;br&gt;看了下，应该是Facebook SDK初始化时候就crash了，同时也有用户反馈App一启动就闪退。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS使用Public Link 进行外部测试</title>
    <link href="http://yoursite.com/2020/03/13/iOS%E4%BD%BF%E7%94%A8Public-Link-%E8%BF%9B%E8%A1%8C%E5%A4%96%E9%83%A8%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/03/13/iOS%E4%BD%BF%E7%94%A8Public-Link-%E8%BF%9B%E8%A1%8C%E5%A4%96%E9%83%A8%E6%B5%8B%E8%AF%95/</id>
    <published>2020-03-13T06:33:00.000Z</published>
    <updated>2020-06-01T08:34:07.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>public link 是Apple 2018年推出的新功能，可以很低成本的进行外部灰度测试，并且可以零成本的测试内购功能</p></blockquote><p>  最近负责的项目进行了重大改版，准备申请Apple推荐。想先发个Beta版本给Apple的编辑人员看一下，也小范围的进行下灰度测试。最方便的办法就是通过Testflight进行测试。</p><p>  还记得2017年时候申请推荐，发外部测试还需要手动的把Apple工作人员的邮箱添加进去。Apple在2018年推出的public link很好的解决了这个问题。</p><blockquote><p>公共链接可让您与开发团队外部的人员共享您的应用程序，而无需电子邮件或其他联系信息。您可以在社交媒体，消息传递平台，电子邮件活动等上共享公共链接，以扩大Beta测试的可见性。如果您没有一组成熟的外部测试人员，则使用公共链接可能是增加应用程序覆盖面并扩大测试受众的有效方法。</p></blockquote><a id="more"></a><p>具体的步骤其实都是官网可查，这里简单说一下</p><ul><li><h4 id="创建public-link"><a href="#创建public-link" class="headerlink" title="创建public link"></a>创建public link</h4></li></ul><p>打包上传到App Store后，等处理完成。去Testflight页面。创建一个新群组</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143338.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143428.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143440.png" alt=""></p><p>填写完审核信息后，就可以提交审核了。和平时发版的审核时间差不多。</p><p>审核通过后就可以启用public link<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143457.png" alt=""></p><p>启用后可以设置最大测试人数，上限为10000人<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143513.png" alt=""></p><ul><li><h4 id="分发public-link"><a href="#分发public-link" class="headerlink" title="分发public link"></a>分发public link</h4>拿到public link后，就可以发放给用户了</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143609.png" alt=""></p><p>用户点击开始测试，就会去往Testflight。如果没装会去Testflight下载页面。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143634.png" alt=""></p><p>用户接受后就可以正常安装了。同时在Testflight后台，能看到当前接受邀请人员的Apple ID</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143656.png" alt=""></p><ul><li><h4 id="内购测试"><a href="#内购测试" class="headerlink" title="内购测试"></a>内购测试</h4></li></ul><p>如果你的App有内购项目，或者部分功能需要内购才能使用。分发链接时候要谨慎。<br>我们在内部Testflight测试时候，可以使用沙盒账户进行内购购买，当你使用public link进行外部测试时候。这个时候内购环境是一种特殊的内购环境。</p><blockquote><p>public link环境下，用户可以使用自己真实的Apple ID进行内购购买，且不会进行扣费。订阅项目同样不会进行续订</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601143722.png" alt=""></p><blockquote><p>参考资料:<br><a href="https://developer.apple.com/videos/play/wwdc2018/301/" target="_blank" rel="noopener">What’s New in App Store Connect</a><br><a href="https://developer.apple.com/testflight/" target="_blank" rel="noopener">使用TestFlight简化Beta测试</a><br><a href="https://help.apple.com/app-store-connect/#/dev859139543" target="_blank" rel="noopener">邀请外部测试员</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;public link 是Apple 2018年推出的新功能，可以很低成本的进行外部灰度测试，并且可以零成本的测试内购功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  最近负责的项目进行了重大改版，准备申请Apple推荐。想先发个Beta版本给Apple的编辑人员看一下，也小范围的进行下灰度测试。最方便的办法就是通过Testflight进行测试。&lt;/p&gt;
&lt;p&gt;  还记得2017年时候申请推荐，发外部测试还需要手动的把Apple工作人员的邮箱添加进去。Apple在2018年推出的public link很好的解决了这个问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;公共链接可让您与开发团队外部的人员共享您的应用程序，而无需电子邮件或其他联系信息。您可以在社交媒体，消息传递平台，电子邮件活动等上共享公共链接，以扩大Beta测试的可见性。如果您没有一组成熟的外部测试人员，则使用公共链接可能是增加应用程序覆盖面并扩大测试受众的有效方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[IAP]iOS如何使用促销代码</title>
    <link href="http://yoursite.com/2019/08/21/IAP-iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BF%83%E9%94%80%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2019/08/21/IAP-iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BF%83%E9%94%80%E4%BB%A3%E7%A0%81/</id>
    <published>2019-08-21T06:41:00.000Z</published>
    <updated>2020-06-01T08:34:25.202Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近项目上线了Vip订阅功能，包含连续包月和连续包年。上线后市场和运营同事问能不能给一些资深用户送几个月的会员，或者搞活动送会员。因为是海外项目，内购不需要用户系统（我们也没有用户系统）完全依赖Apple购买凭证。所以不能使用国内App那种服务端生成兑换码的做法。</p></blockquote><p>因为完全依赖Apple，所以还是要从Apple这边下手。自然而然想到了Apple的促销代码。<br>先看看什么是促销代码 <a href="https://help.apple.com/app-store-connect/#/dev50869de4a" target="_blank" rel="noopener">官方文档戳这里</a></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601144252.png" alt=""></p><p>可以看到，促销代码是可以兑换内购项目的，并且订购一个自动续期的订阅并不会自动续费。</p><a id="more"></a><ul><li><h3 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h3>在App Store Connect后台找到了促销代码，点击你所需要兑换的内购项目，新增即可<br>具体的还是看 <a href="https://help.apple.com/app-store-connect/#/dev1e322b132" target="_blank" rel="noopener">官方文档</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601144324.png" alt=""></p><p>注意下申请出来的代码有时间限制，28天之内不用就会过期。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601144348.png" alt=""></p><p>申请以后从历史记录中就可以看到代码，把这个神秘代码发给用户即可。<br>当然，一般用户都会一脸懵逼，不知道如何兑换</p><ul><li><h3 id="兑换"><a href="#兑换" class="headerlink" title="兑换"></a>兑换</h3><p>首先打开手机上的App Store，选中App那一栏，拖到底，点击兑换<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601144419.png" alt=""></p><p>然后输入密码什么的一直继续</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601144446.png" alt=""></p><p>选中手动输入，输入之前申请的促销码</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601144515.png" alt=""></p><p>用户如果之前下载过，就可以直接打开，未下载这里就是下载按钮。<br>打开App后发现会员已经生效，看日志确实收到了购买成功的回调。并且上报的购买价格是0</p><blockquote><p>这个方法同样可以测试线上的购买流程，上线后想回测下又舍不得花钱或者报销麻烦，都可以用这种方法测试</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近项目上线了Vip订阅功能，包含连续包月和连续包年。上线后市场和运营同事问能不能给一些资深用户送几个月的会员，或者搞活动送会员。因为是海外项目，内购不需要用户系统（我们也没有用户系统）完全依赖Apple购买凭证。所以不能使用国内App那种服务端生成兑换码的做法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为完全依赖Apple，所以还是要从Apple这边下手。自然而然想到了Apple的促销代码。&lt;br&gt;先看看什么是促销代码 &lt;a href=&quot;https://help.apple.com/app-store-connect/#/dev50869de4a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601144252.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，促销代码是可以兑换内购项目的，并且订购一个自动续期的订阅并不会自动续费。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>解决Pod&quot; target has libraries with conflicting names&quot;冲突</title>
    <link href="http://yoursite.com/2019/05/31/11/"/>
    <id>http://yoursite.com/2019/05/31/11/</id>
    <published>2019-05-31T07:57:00.000Z</published>
    <updated>2020-06-01T08:34:38.422Z</updated>
    
    <content type="html"><![CDATA[<p>最近在导入pod时候遇到</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">The <span class="symbol">'Pods</span>-XXX target has libraries <span class="keyword">with</span> conflicting names: xxxx.a.</span><br></pre></td></tr></table></figure><p>这个问题是因为两个不同的pod都依赖了同一个.a文件造成了冲突。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601155748.png" alt=""></p><a id="more"></a><p> 首先我们应该知道是那两个库冲突了，从图上看我们的内部仓库“YDOfflineOcr”肯定是依赖了“libprotobuf.a”文件。但是另外一个库就不是那么好找了。有一个笨办法就是你挨个去看每个有podspec文件的仓库，去看看都依赖了那些库。还有偷懒的办法就是把你认为冲突的库注释掉，执行pod install,看看会去除那些文件。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601155812.png" alt=""><br>经过测试发现是”Firebase/Messaging” 这个仓库依赖了Protobuf这个库。我们可以去”Firebase/Messaging”的podspec看下  <a href="https://github.com/firebase/firebase-ios-sdk/blob/master/FirebaseMessaging.podspec" target="_blank" rel="noopener">FirebaseMessaging.podspec</a></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601155834.png" alt=""><br>下面是我们私有库的podspec文件，导入了libs下的所有.a文件。这个文件下也有libprotobug.a</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601155850.png" alt=""></p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>知道那两个库后就可以解决这个问题了，解决办法是自己建立一个podspec文件，把其中一个库指定到这个podspec路径,这里我选择该自己的私有库。</p><p>#####解决办法很简单粗暴，在冲突的两个库中去掉一个库的依赖。修改其中一个库的podspec</p><p>首先找到库的podspec文件，选择raw模式，这样就能拿到纯净的文本。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601155914.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601155925.png" alt=""></p><p>然后copy出来，新建一个文件叫xxx.podspec，copy文本，修改podspec文件。首先找到verdored_library，之前是我这边写的是引用Libs下所有的，那就改成挨个引入（按你们自己的实际情况来）</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601155945.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601155958.png" alt=""><br>然后建立一个仓库，把这个podspec文件放进去，上传到Git<br>假设地址为：<br><a href="https://gitlab.corp.youdao.com/liwc/udpodspec/blob/master/YDOfflineOcr.podspec" target="_blank" rel="noopener">https://gitlab.corp.youdao.com/liwc/udpodspec/blob/master/YDOfflineOcr.podspec</a><br>这里要使用纯净文本，所以blob 要改为raw，确保打开连接必须是一个纯文本<br>就如下面这个链接这样（gitlab和github的raw模式不同，注意raw模式即可）<br><a href="https://raw.githubusercontent.com/firebase/firebase-ios-sdk/master/FirebaseMessaging.podspec" target="_blank" rel="noopener">https://raw.githubusercontent.com/firebase/firebase-ios-sdk/master/FirebaseMessaging.podspec</a></p><p>Ok，我们现在有自己的podspec文件和地址了。那么只需你在引入pod时候指定podspec即可</p><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">'YDOfflineOcr'</span>, :<span class="function"><span class="params">podspec</span> =&gt;</span> <span class="string">'https://gitlab.corp.youdao.com/liwc/udpodspec/raw/master/YDOfflineOcr.podspec'</span></span><br></pre></td></tr></table></figure><p>再次执行pod install，导入成功。</p><p>当然我也可以移除firbase下podspec的依赖库<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601160011.png" alt=""><br>把protobuf移除后，上传到自己的仓库，指定podspec<br>可以根据自己情况选择处理那个库。</p><p>其实正确的做法是pod里不直接放.a文件。通用的三方库用依赖的方式导入。<br>podspec中写<br>s.dependency ‘xxx’, ‘~&gt; 3.1’</p><blockquote><p>有些依赖库在内部引用并不是根据名字来引用的，比如外面的私有库引用了xxx.a。这个.a文件是直接在包里面的。这时候我只需要改一下.a的名字。就可以过pod校验。并且运行起来完全没问题</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在导入pod时候遇到&lt;/p&gt;
&lt;figure class=&quot;highlight ada&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The &lt;span class=&quot;symbol&quot;&gt;&#39;Pods&lt;/span&gt;-XXX target has libraries &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; conflicting names: xxxx.a.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个问题是因为两个不同的pod都依赖了同一个.a文件造成了冲突。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601155748.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Widget开发指南</title>
    <link href="http://yoursite.com/2018/11/12/Widget%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/11/12/Widget%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</id>
    <published>2018-11-12T12:05:00.000Z</published>
    <updated>2020-06-01T06:13:50.067Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目前负责的App新增了Widget功能，之后在组内分享中分享了下Widget的开发经验。基于之前的PPT提炼出了这篇文章。本篇文章只讲基于Widget关于iOS10+ 之后的知识点。</p></blockquote><p>Widget是iOS8以后Apple推出的一项功能，并且在iOS10后进行了大幅的优化。</p><p>在主屏幕和锁定屏幕上向右滑动来访问Widget,也可以在对应的App图标上面使用3D Touch按压访问相应的Widget。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121241.png" alt=""></p><a id="more"></a><h1 id="Widget设计规范和要求"><a href="#Widget设计规范和要求" class="headerlink" title="Widget设计规范和要求"></a>Widget设计规范和要求</h1><p>Widget是一个单独的进程，和主App独立，但是支持数据共享。在设计和开发Widget时候要注意以下几点设计规范：</p><ul><li><p><strong>设计一个友好的交互体验</strong></p><p>Widget用来执行非常简单的任务，尽可能提供点击一次就能完成的任务，Widget不支持窗口滚动，不支持键盘输入（其实是可以做到键盘输入的 具体办法见后面）<br>详见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Today.html" target="_blank" rel="noopener">《App Extension Programming Guide》</a></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121350.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121409.png" alt=""></p><ul><li><p><strong>要快速显示内容</strong></p><p>  内容要尽量从本地加载，依赖网络的内容要在本地做缓存，以免长时间等待。确保每次出现都有内容</p></li><li><p><strong>提供充足的边距和填充</strong></p><p>  避免将内容扩展到Widegt边缘。<strong>每行最多显示4个按钮或图标</strong></p></li><li><p><strong>适应屏幕</strong></p><p>  iOS10以后，Widget支持折叠和展开。<strong>折叠状态下默认高度为110且不可更改。展开高度不超过一个屏幕的高度</strong>。（官方文档说最低高度为2.5个默认行高 44<em>3.5=110）官方推荐使用AutoLayout布局。<br>  *</em>横屏时候宽度还是默认屏幕宽度。不会拉伸**<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121436.png" alt=""></p></li><li><p><strong>不要自定义背景色</strong></p><p>  系统自带模糊的背景色，尽量不要改(当然只是建议咯）。不要用照片做背景，会和壁纸冲突。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121508.png" alt=""></p></li><li><p><strong>注意字体颜色、取一个好名字、一个App可以有多个Widget</strong></p><p>  字体颜色尽量是深色或者深灰色（然而用白色的最多）。如果一个App存在多个Widget，要命名清晰。Widget的名字里面，<strong>英文字母系统会自动转换成大写</strong>。</p><p>  <strong>Logo会自动使用主App的icon</strong></p></li><li><p><strong>适当的时候让用户跳转到主App来做更多的事</strong></p><p>  Widget尽量只给用户提供简单的功能（规范而已。。），不要在Widget中出现“打开App”等按钮。点击Widget icon后会自动吊起主App。和主App交互使用URLScheme方法。后面会讲到。</p></li><li><p><strong>很短的生命周期、要注意内存问题</strong></p><p>离开屏幕2s+就会被销毁，后面会讲到</p></li></ul><h1 id="建立Widget-Target"><a href="#建立Widget-Target" class="headerlink" title="建立Widget Target"></a>建立Widget Target</h1><p>选择主工程，在Project设置界面下方点击加号，新建Today Extension</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121536.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121558.png" alt=""><br>系统会自动生成TodayViewController和storyBoard。不要忘记在Target设置里面设置基本信息，版本号和主App保持一致，否则上传iTunes Connect会有警告邮件</p><p><strong>也要注意选择Deployment Target。Xcode10默认是iOS12</strong><br><img src="https://upload-images.jianshu.io/upload_images/525360-3793f8a5b159e998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="和Widget共享代码"><a href="#和Widget共享代码" class="headerlink" title="和Widget共享代码"></a>和Widget共享代码</h1><ul><li><p>支持pod导入三方库，在podfile中新增Widget的target<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121627.png" alt="">Xcode10 后，如果在Build Phases中运行Script。执行pod可能报错。解决办法见<br><a href="https://www.jianshu.com/p/ebdcfc86886b" target="_blank" rel="noopener">《#iOS知识小集# Xcode10 pod install 报错》</a></p></li><li><p>主工程代码共享<br>在需要共享的类的.m文件中的Target Membership中勾选Widget所在的Target<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121710.png" alt=""></p></li></ul><h1 id="Widget代码实现"><a href="#Widget代码实现" class="headerlink" title="Widget代码实现"></a>Widget代码实现</h1><p><strong>NCWidgetProviding协议</strong><br>Widget工程建立后会自动生成TodayViewController。<br>会遵循NCWidgetProviding协议<br>iOS10以后这个协议只有两个方法</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">widgetPerformUpdateWithCompletionHandler</span><span class="selector-pseudo">:(void</span> (^)(NCUpdateResult result))<span class="selector-tag">completionHandler</span>;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">widgetActiveDisplayModeDidChange</span><span class="selector-pseudo">:(NCWidgetDisplayMode)activeDisplayMode</span> <span class="selector-tag">withMaximumSize</span><span class="selector-pseudo">:(CGSize)maxSize</span> <span class="selector-tag">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</span><br></pre></td></tr></table></figure><p>其中widgetPerformUpdateWithCompletionHandler 默认返回NCUpdateResultNewData</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)widgetPerformUpdateWithCompletionHandler:(<span class="type">void</span> (^)(NCUpdateResult))completionHandler &#123;</span><br><span class="line">    // <span class="keyword">Perform</span> <span class="keyword">any</span> setup necessary <span class="keyword">in</span> <span class="keyword">order</span> <span class="keyword">to</span> <span class="keyword">update</span> the <span class="keyword">view</span>.</span><br><span class="line">    </span><br><span class="line">    // <span class="keyword">If</span> an error <span class="keyword">is</span> encountered, use NCUpdateResultFailed</span><br><span class="line">    // <span class="keyword">If</span> ther<span class="string">e's no update required, use NCUpdateResultNoData</span></span><br><span class="line"><span class="string">    // If there'</span>s an <span class="keyword">update</span>, use NCUpdateResultNewData</span><br><span class="line"></span><br><span class="line">    completionHandler(NCUpdateResultNewData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个可以忽略掉，直接返回NCUpdateResultNewData就好了<br>iOS10以后支持折叠和展开功能，折叠状态下默认高度为110且不可更改。展开高度不超过一个屏幕的高度。（官方文档说最低高度为2.5个默认行高 44*3.5=110）</p><p>在ViewDidLoaded方法中设置是否开启折叠功能</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NCWidgetDisplayModeCompact 收起模式</span></span><br><span class="line"><span class="comment">//NCWidgetDisplayModeExpanded  展开模式</span></span><br><span class="line">     </span><br><span class="line"><span class="literal">self</span>.extensionContext.widgetLargestAvailableDisplayMode = NCWidgetDisplayModeExpanded;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)widgetActiveDisplayModeDidChange:(NCWidgetDisplayMode)activeDisplayMode withMaximumSize:(<span class="built_in">CGSize</span>)maxSize &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (activeDisplayMode == NCWidgetDisplayModeCompact) &#123;</span><br><span class="line">        <span class="keyword">self</span>.preferredContentSize = <span class="built_in">CGSizeMake</span>(maxSize.width, <span class="number">110</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.preferredContentSize = <span class="built_in">CGSizeMake</span>(maxSize.width, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用纯代码</strong></p><p>示例工程会默认使用StoryBoard，如果想使用纯代码。进行以下步骤</p><ol><li>删除MainInterface.storyboard文件和NSExtensionMainStoryboard键值对<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121837.png" alt=""></li><li>添加NSExtensionPrincipalClass为key ,value为TodayViewController<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121932.png" alt=""></li></ol><p><strong>图片管理</strong><br>Widget可以使用Asset Catalog管理图片，命名为Assets，和主工程使用方式一致</p><p><strong>代码调试</strong><br>在Widget工程更新代码后，可以运行主工程，然后添加Widget。就可以看到最新的效果展示。<br>如果想断点调试，要选择Widget Target<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141147.png" alt=""><br><strong>和主工程共享数据</strong></p><blockquote><p>Widget和主工程是完全独立的两个工程,两个独立的进程。所以数据共享是通过App Groups进行的。</p></blockquote><p>App Groups需要去开发者中心去创建。ID必须以group开头。后面一般跟公司名称。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141205.png" alt=""><br>建立完成后回到主工程，打开App Groups开关，就能刷新出刚刚创建的Groups,打钩远中</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141214.png" alt=""><br>然后把Widget Target 也打开App Groups，选中同一个Groups</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141231.png" alt=""><br>App Groups可以通过NSUserDefaults和NSFileManager共享数据</p><ul><li>NSUserDefaults</li></ul><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主工程中存</span></span><br><span class="line">NSUserDefaults *shared = [[NSUserDefaults alloc] <span class="string">initWithSuiteName:</span>@<span class="string">"group.YouDao.xxxx"</span>];</span><br><span class="line">[shared <span class="string">setObject:</span>_targetLanguage.abb <span class="string">forKey:</span>@<span class="string">"UD_TargetLanguage_Widget_key"</span>];</span><br><span class="line">[shared synchronize];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Widget 中取</span></span><br><span class="line">[[NSUserDefaults alloc] <span class="string">initWithSuiteName:</span>@<span class="string">"group.YouDao.xxxx"</span>] <span class="string">objectForKey:</span>@<span class="string">"UD_TargetLanguage_Widget_key"</span>];</span><br></pre></td></tr></table></figure><ul><li>NSFileManager</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存</span></span><br><span class="line"><span class="built_in">NSString</span> *groupID = <span class="string">@"group.YouDao.xxxx"</span>;</span><br><span class="line"><span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSURL</span> *fileUrl = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:groupID];</span><br><span class="line">fileUrl = [fileUrl URLByAppendingPathComponent:<span class="string">@"Library/Caches/test"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *value = <span class="string">@"test"</span>;</span><br><span class="line"><span class="built_in">BOOL</span> result = [value writeToURL:fileUrl atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;err];</span><br><span class="line"><span class="keyword">if</span>(result)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"写入成功"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取</span></span><br><span class="line"><span class="built_in">NSString</span> *groupID = <span class="string">@"group.YouDao.xxxx"</span>;</span><br><span class="line"><span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSURL</span> *containerURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:groupID];</span><br><span class="line">containerURL = [containerURL URLByAppendingPathComponent:<span class="string">@"Library/Caches/test"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *value = [<span class="built_in">NSString</span> stringWithContentsOfURL:containerURL encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;err];</span><br></pre></td></tr></table></figure><blockquote><p>App Gropu是跨App的，只要在同一个开发中账号。不同的App使用同一个Gropu ID都是可以共享数据的。在Shared目录下还有AppGroup目录。里面有各个Group ID的文件夹。其中通过NSUserDefault共享的数据在Library/Prefrences下。是一个plist文件。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141243.png" alt=""></p><h1 id="Widget吊起主工程"><a href="#Widget吊起主工程" class="headerlink" title="Widget吊起主工程"></a>Widget吊起主工程</h1><p>Widget吊起主App通过URLSchemes</p><ol><li>为主App设置URLSchemes<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141310.png" alt=""><br>￼￼2.Widget添加交互<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">self.extensionContext</span> openURL:[<span class="name">NSURL</span> URLWithString:@<span class="string">"YDUDictionary://action=CameraTranslate"</span>] completionHandler:^(<span class="name">BOOL</span> success) &#123;</span><br><span class="line">                NSLog(<span class="name">@</span><span class="string">"open url result:%d"</span>,success)<span class="comment">;</span></span><br><span class="line">            &#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>主App中处理Scheme.在AppDelegate中实现application:openURL:options:<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationOpenURLOptionsKey</span>,<span class="keyword">id</span>&gt; *)options &#123;</span><br><span class="line">      <span class="built_in">NSString</span> *urlStr = [url.absoluteString stringByRemovingPercentEncoding];</span><br><span class="line">        <span class="keyword">if</span> ([urlStr hasPrefix:<span class="string">@"YDUDictionary://action="</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *parameter = [urlStr stringByReplacingOccurrencesOfString:<span class="string">@"YDUDictionary://action="</span> withString:<span class="string">@""</span>];</span><br><span class="line">                <span class="keyword">if</span> ([parameter isEqualToString:<span class="string">@"CameraTranslate"</span>]) &#123;</span><br><span class="line">                <span class="comment">//Do Somthinhg</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="主App中控制Widget是否显示"><a href="#主App中控制Widget是否显示" class="headerlink" title="主App中控制Widget是否显示"></a>主App中控制Widget是否显示</h1><p>在Widget编辑页面可以进行Widget排序很删减。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141322.png" alt="">当添加Widget以后，主工程还可以控制Widget是否显示。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为什么要引入NotificationCenter呢？可以思考下</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;NotificationCenter/NotificationCenter.h&gt;</span></span></span><br><span class="line"><span class="comment">//youdao.com.WidgetTest.Widget是Widget的Bundle ID</span></span><br><span class="line">[[NCWidgetController widgetController] setHasContent:<span class="literal">YES</span> forWidgetWithBundleIdentifier:<span class="string">@"youdao.com.WidgetTest.Widget"</span>];</span><br></pre></td></tr></table></figure><h1 id="刷新机制"><a href="#刷新机制" class="headerlink" title="刷新机制"></a>刷新机制</h1><p>Widget有自己进程，有特殊的生命周期和内存限制。通过测试得出</p><blockquote><p>Widget离开屏幕2s以上，就会被销毁回收掉。每次离开前系统会做快照处理。下次进来先加载快照。<br>离开超过2s以上，下次进入就会调用ViewDidLoad,然后是viewWillAppear<br>离开不超过2s 下次进入会调用viewWillAppear</p></blockquote><p>所以为了交互体验，最好是记录用户上次的使用状态，下次加载时候进行还原操作。</p><p>当内存不足时候，系统会优先kill掉Widget。所以要注意内存问题，不要进行需要大量内存的操作。<br>网络请求如果需要频繁刷新。可以在viewWillAppear方法中启用一个Timer,在Timer中请求接口数据。在viewWillDisAppear中取消定时器。</p><h1 id="如何在Widget中使用键盘"><a href="#如何在Widget中使用键盘" class="headerlink" title="如何在Widget中使用键盘"></a>如何在Widget中使用键盘</h1><blockquote><p>Apple官方文档说Widget是不支持键盘输入的。如果在TodayViewController中新建一个输入框。点击是没有反应的。但是我们可以用另外一种办法绕过去。效果如下图。</p></blockquote><p><strong>做法就是做一个假的输入框，让用户点击。点击后present一个ViewController，在这个Controller新建UITextView或者UITextField就可以获取焦点，出现键盘啦</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141336.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;目前负责的App新增了Widget功能，之后在组内分享中分享了下Widget的开发经验。基于之前的PPT提炼出了这篇文章。本篇文章只讲基于Widget关于iOS10+ 之后的知识点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Widget是iOS8以后Apple推出的一项功能，并且在iOS10后进行了大幅的优化。&lt;/p&gt;
&lt;p&gt;在主屏幕和锁定屏幕上向右滑动来访问Widget,也可以在对应的App图标上面使用3D Touch按压访问相应的Widget。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601121241.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Widget" scheme="http://yoursite.com/tags/Widget/"/>
    
  </entry>
  
  <entry>
    <title>NSAssert详解及C语言assert的一些坑</title>
    <link href="http://yoursite.com/2018/10/13/C%E8%AF%AD%E8%A8%80assert%E5%9C%A8Xcode%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2018/10/13/C%E8%AF%AD%E8%A8%80assert%E5%9C%A8Xcode%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</id>
    <published>2018-10-13T02:53:00.000Z</published>
    <updated>2020-11-30T17:48:59.972Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201013152501.png" alt=""><br>assert大家都不陌生，在开发阶段用断言函数可以很好的进行调试。</p><p>一般OC中，我们使用的是<code>NSAssert</code>。在Xcode4.2以后，Xcode会在release环境下自动把<code>NSAssert</code>忽略掉，确保release环境不会出错。</p><h2 id="assert的坑"><a href="#assert的坑" class="headerlink" title="assert的坑"></a>assert的坑</h2><p>最近遇到一个问题，线上Crash定位在了一个pod库中的<code>assert</code>方法，在OC里面调用assert是用的C语言的assert。结果在<code>release</code>环境下也生效了，直接造成了Crash。</p><p>查找了一些资料，找到了解决方案。</p><p>通过查询源码发现，在C语言中是如何忽略的<code>assert</code>的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> assert</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __assert</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>assert(e)((void)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __GNUC__</span></span><br></pre></td></tr></table></figure><p>源码地址详见：<a href="https://opensource.apple.com/source/Libc/Libc-583/include/assert.h.auto.html" target="_blank" rel="noopener">https://opensource.apple.com/source/Libc/Libc-583/include/assert.h.auto.html</a></p><p><code>NDEBUG</code>是C语言中的一个标准宏，其语义适用于C89，C99，C ++ 98，C ++ 2003，C ++ 2011，C ++ 2014标准。<br>详见：<a href="https://stackoverflow.com/questions/2290509/debug-vs-ndebug" target="_blank" rel="noopener">https://stackoverflow.com/questions/2290509/debug-vs-ndebug</a></p><p>根据源码可知，如果定义了<code>NDEBUG</code>，那么<code>assert</code>就返回<code>void</code>，就不会再生效。</p><p>那么我们只需要在主工程中，选择<code>Bulid Settings</code>选择<code>Preprocessor Marcos</code>在<code>Release</code>中添加<code>NDEBUG=1</code>即可。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201019102527.png" alt=""></p><blockquote><p><strong>但是需要注意的是，只修改主工程并不会对pod库生效，所以还需要对pod库进行处理！</strong></p></blockquote><p>在pod库中一个一个修改太麻烦，并且每次<code>pod install</code>后就会失效，我们需要从<code>podfile</code>文件入手。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">   installer.pods_project.targets.each <span class="keyword">do</span> <span class="params">|target|</span></span><br><span class="line">     target.build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">       config.build_settings[<span class="string">'IPHONEOS_DEPLOYMENT_TARGET'</span>] = <span class="string">'10.0'</span></span><br><span class="line">       <span class="keyword">if</span> config.name == <span class="string">'Release'</span></span><br><span class="line">         config.build_settings[<span class="string">'GCC_PREPROCESSOR_DEFINITIONS'</span>] <span class="params">||</span>= [<span class="string">'$(inherited)'</span>, <span class="string">'NDEBUG=1'</span>]</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>判断是否是<code>Release</code>环境，如果是就在<code>build_settings</code>中的<code>GCC_PREPROCESSOR_DEFINITIONS</code>添加<code>$(inherited)</code>和 <code>NDEBUG=1</code>。</p><p><code>$(inherited)</code>是继承<code>Pods</code>工程的设置</p><p>添加完后执行<code>pod install</code>，就可以发现每个pod库的<code>Preprocessor Marcos</code>中，在<code>Release</code>下都添加了<code>NDEBUG=1</code><br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201019103641.png" alt=""></p><h2 id="NSAssert介绍"><a href="#NSAssert介绍" class="headerlink" title="NSAssert介绍"></a>NSAssert介绍</h2><p>说完assert,再来说说我们常用的<code>NSAssert</code></p><p><code>NSAssert</code>细分为</p><ul><li><code>NSAssert/NSCAsseet</code></li><li><code>NSParameterAssert / NSCParameterAssert</code></li></ul><p>他们的区别如下：</p><ol><li><p>NSAssert 和 NSParameterAssert 只适用于OC环境中。NSCAsseet 和 NSCParameterAssert 适用于C语言环境中</p></li><li><p>当 NSAssert 或 NSParameterAssert 的条件不满足时，断言处理器会调用<br><code>-handleFailureInMethod:object:file:lineNumber:description:</code>方法。<br>当 NSCAssert 或 NSCParameterAssert 的条件不满足时，断言处理器会调用 <code>-handleFailureInFunction:file:lineNumber:description:</code> 方法。</p></li></ol><p>NSAssert和NSAssert都有一些变体，例如<code>NSAssert1</code>、<code>NSAssert2</code>、<code>NSCAssert1</code>、<code>NSCAssert2</code>等等。他们的区别是会输出不同的参数。<br>具体信息详见官方文档：<a href="https://developer.apple.com/documentation/foundation/nsassert1" target="_blank" rel="noopener">https://developer.apple.com/documentation/foundation/nsassert1</a></p><p>从Xcode4.2以后，会自动在release环境下忽略<code>NSAssert</code>等断言函数。它是通过定义 <code>NS_BLOCK_ASSERTIONS</code> 宏实现的，确保不会对release环境有影响。</p><p>我们可以在很多第三方库中看到他们定义的assert,关闭条件也是基于<code>NS_BLOCK_ASSERTIONS</code></p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> <span class="selector-tag">_GTMDevAssert</span></span><br><span class="line"><span class="comment">// we directly invoke the NSAssert handler so we can pass on the varargs</span></span><br><span class="line"><span class="comment">// (NSAssert doesn't have a macro we can use that takes varargs)</span></span><br><span class="line"><span class="selector-id">#if</span> !<span class="selector-tag">defined</span>(NS_BLOCK_ASSERTIONS)</span><br><span class="line">  <span class="selector-id">#define</span> <span class="selector-tag">_GTMDevAssert</span>(condition, ...)                                       \</span><br><span class="line">    <span class="selector-tag">do</span> &#123;                                                                      \</span><br><span class="line">      <span class="selector-tag">if</span> (!(condition)) &#123;                                                     \</span><br><span class="line">        <span class="selector-attr">[[NSAssertionHandler currentHandler]</span>                                  \</span><br><span class="line">            <span class="selector-tag">handleFailureInFunction</span><span class="selector-pseudo">:(NSString</span> *)                              \</span><br><span class="line">                                        <span class="selector-attr">[NSString stringWithUTF8String:__PRETTY_FUNCTION__]</span> \</span><br><span class="line">                               <span class="selector-tag">file</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-attr">[NSString stringWithUTF8String:__FILE__]</span>  \</span><br><span class="line">                         <span class="selector-tag">lineNumber</span><span class="selector-pseudo">:__LINE__</span>                                  \</span><br><span class="line">                        <span class="selector-tag">description</span><span class="selector-pseudo">:__VA_ARGS__</span>];                             \</span><br><span class="line">      &#125;                                                                       \</span><br><span class="line">    &#125; <span class="selector-tag">while</span>(<span class="number">0</span>)</span><br><span class="line"><span class="selector-id">#else</span> <span class="comment">// !defined(NS_BLOCK_ASSERTIONS)</span></span><br><span class="line">  <span class="selector-id">#define</span> <span class="selector-tag">_GTMDevAssert</span>(condition, ...) <span class="selector-tag">do</span> &#123; &#125; <span class="selector-tag">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="selector-id">#endif</span> <span class="comment">// !defined(NS_BLOCK_ASSERTIONS)</span></span><br></pre></td></tr></table></figure><p><code>NSAssert</code>和<code>NSCAssert</code>底层都是通过<code>NSAssertionHandler</code>来实现的，只有2个实现方法</p><ul><li><code>-handleFailureInMethod:object:file:lineNumber:description:</code>  NSAssert/NAParamterAssert调用</li><li><code>-handleFailureInFunction:file:lineNumber:description:</code> NSCAssert/NACParamterAssert调用</li></ul><p>Xcode的开关在<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201201014436.png" alt=""></p><p>我们也可以自定义NSAssert</p><p>继承NSAssertionHandler，重写<code>handleFailureInFunction:file:lineNumber:description</code>和<code>handleFailureInMethod:object:file:lineNumber:description:</code><br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201201014548.png" alt=""></p><p>在AppDelegate中注册</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="built_in">NSAssertionHandler</span> *handler = [[UDTestAssertHandler alloc] init];</span><br><span class="line">    [[[<span class="built_in">NSThread</span> currentThread] threadDictionary] setValue:handler</span><br><span class="line">                                                   forKey:<span class="built_in">NSAssertionHandlerKey</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NSAssert的坑"><a href="#NSAssert的坑" class="headerlink" title="NSAssert的坑"></a>NSAssert的坑</h2><p>NSAssert在OC中，会存在循环引用问题</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)buttonAction:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    TestMode *mode = [TestMode new];</span><br><span class="line">    <span class="keyword">self</span>.mode = mode;</span><br><span class="line"><span class="comment">//    @weakify(self);</span></span><br><span class="line">    mode.textBlock = ^&#123;</span><br><span class="line"><span class="comment">//        @strongify(self);</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">NSParameterAssert</span>(k == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"123"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    mode.textBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环引用的根源在于NSAssert定义中使用了self</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#if</span> !<span class="selector-tag">defined</span>(_NSAssertBody)</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">NSAssert</span>(condition, desc, ...)\</span><br><span class="line">    <span class="selector-tag">do</span> &#123;\</span><br><span class="line"><span class="selector-tag">__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS</span> \</span><br><span class="line"><span class="selector-tag">if</span> (__builtin_expect(!(condition), <span class="number">0</span>)) &#123;\</span><br><span class="line">    <span class="selector-attr">[[NSAssertionHandler currentHandler]</span> <span class="selector-tag">handleFailureInMethod</span><span class="selector-pseudo">:_cmd</span> \</span><br><span class="line"><span class="selector-tag">object</span><span class="selector-pseudo">:self</span> <span class="selector-tag">file</span>:@(__FILE_NAME__) \</span><br><span class="line">    <span class="selector-tag">lineNumber</span><span class="selector-pseudo">:__LINE__</span> <span class="selector-tag">description</span><span class="selector-pseudo">:(desc)</span>, #<span class="selector-id">#__VA_ARGS__</span>]; \</span><br><span class="line">&#125;\</span><br><span class="line">        <span class="selector-tag">__PRAGMA_POP_NO_EXTRA_ARG_WARNINGS</span> \</span><br><span class="line">    &#125; <span class="selector-tag">while</span>(<span class="number">0</span>)</span><br><span class="line"><span class="selector-id">#endif</span></span><br></pre></td></tr></table></figure><p>我们可以试用@weakself 和 @strongself来解决。不过在release环境下，assert并不会调用。所以推荐试用<code>NSCAssert</code>和 <code>NSParameterAssert</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20201013152501.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;assert大家都不陌生，在开发阶段用断言函数可以很好的进行调试。&lt;/p&gt;
&lt;p&gt;一
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>UIActivityViewController 在iOS11上的坑</title>
    <link href="http://yoursite.com/2017/11/28/UIActivityViewController-%E5%9C%A8iOS11%E4%B8%8A%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2017/11/28/UIActivityViewController-%E5%9C%A8iOS11%E4%B8%8A%E7%9A%84%E5%9D%91/</id>
    <published>2017-11-28T06:48:00.000Z</published>
    <updated>2020-06-01T08:34:51.302Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在做针对国外用户的App，考虑到国外都是Facebook和Twitter等社交平台，所以考虑使用iOS系统中的原生分享。但是在iOS11上面遇到一些坑，遂记录一下。</p></blockquote><p>在iOS11以下的版本中，系统默认集成了社交账号的功能。但是在iOS11中内置的社交账号被移除了。并且在iOS11中废弃了一些方法。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">SOCIAL_EXTERN NSString *<span class="keyword">const</span> SLServiceTypeTwitter NS_DEPRECATED(<span class="number">10</span>_8, <span class="number">10</span>_13, <span class="number">6</span>_0, <span class="number">11</span>_0);</span><br><span class="line">SOCIAL_EXTERN NSString *<span class="keyword">const</span> SLServiceTypeFacebook NS_DEPRECATED(<span class="number">10</span>_8, <span class="number">10</span>_13, <span class="number">6</span>_0, <span class="number">11</span>_0);</span><br><span class="line">SOCIAL_EXTERN NSString *<span class="keyword">const</span> SLServiceTypeSinaWeibo NS_DEPRECATED(<span class="number">10</span>_8, <span class="number">10</span>_13, <span class="number">6</span>_0, <span class="number">11</span>_0);</span><br><span class="line">SOCIAL_EXTERN NSString *<span class="keyword">const</span> SLServiceTypeTencentWeibo NS_DEPRECATED(<span class="number">10</span>_8, <span class="number">10</span>_13, <span class="number">6</span>_0, <span class="number">11</span>_0);</span><br><span class="line">SOCIAL_EXTERN NSString *<span class="keyword">const</span> SLServiceTypeLinkedIn NS_DEPRECATED(<span class="number">10</span>_8, <span class="number">10</span>_13, <span class="number">6</span>_0, <span class="number">11</span>_0);</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用系统分享可以使用<code>UIActivityViewController</code>和<code>SLComposeViewController</code>。但是在iOS11中<code>SLComposeViewController</code>已经无法使用。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">BOOL <span class="built_in">available</span> = [SLComposeViewController isAvailableForServiceType:SLServiceTypeSinaWeibo];</span><br><span class="line">  <span class="comment">//iOS11系统中使用这个方法应该所有平台都是NO</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">available</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所以只能使用<code>UIActivityViewController</code>。使用系统的分享SDK好处还是很多的。不用再各个平台上申请账号，申请Key，设置白名单等等，只需几行代码就能优雅的实现分享功能。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *textToShare = <span class="string">@"test titile"</span>;</span><br><span class="line"><span class="built_in">UIImage</span>* imageShare = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"logo"</span>];</span><br><span class="line"><span class="built_in">NSURL</span> *urlShare = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.youdao.com"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *activityItems = @[textToShare, imageShare, urlShare];</span><br><span class="line"><span class="built_in">UIActivityViewController</span> *actVC = [[<span class="built_in">UIActivityViewController</span> alloc] initWithActivityItems:activityItems applicationActivities:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//excludedActivityTypes 是排除那些分享功能，数组里面的都不显示</span></span><br><span class="line">actVC.excludedActivityTypes = @[<span class="built_in">UIActivityTypeMessage</span>,<span class="built_in">UIActivityTypePrint</span>,<span class="built_in">UIActivityTypeSaveToCameraRoll</span>,<span class="built_in">UIActivityTypeAddToReadingList</span>,<span class="built_in">UIActivityTypePostToFlickr</span>,<span class="built_in">UIActivityTypePostToVimeo</span>,<span class="built_in">UIActivityTypeAirDrop</span>];</span><br><span class="line"><span class="comment">//区分iPad 和 iPhone</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">UI_USER_INTERFACE_IDIOM</span>() == <span class="built_in">UIUserInterfaceIdiomPad</span>) &#123;</span><br><span class="line">    actVC.popoverPresentationController.sourceView = <span class="keyword">self</span>.view;</span><br><span class="line">      [<span class="keyword">self</span> presentViewController:actVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [<span class="keyword">self</span> presentViewController:actVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  actVC.completionWithItemsHandler = ^(<span class="built_in">UIActivityType</span>  _Nullable activityType, <span class="built_in">BOOL</span> completed, <span class="built_in">NSArray</span> * _Nullable returnedItems, <span class="built_in">NSError</span> * _Nullable activityError) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"===%@"</span>,returnedItems);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>excludedActivityTypes是剔除那些分享功能，枚举如下</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypePostToFacebook</span>     <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) __TVOS_PROHIBITED;    <span class="comment">//发送到Facebook</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypePostToTwitter</span>      <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) __TVOS_PROHIBITED;    <span class="comment">//发送到Twitter</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypePostToWeibo</span>        <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) __TVOS_PROHIBITED;    <span class="comment">//发送到新浪微博</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypeMessage</span>            <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) __TVOS_PROHIBITED;    <span class="comment">//短信</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypeMail</span>               <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) __TVOS_PROHIBITED;    <span class="comment">//邮件</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypePrint</span>              <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) __TVOS_PROHIBITED;    <span class="comment">//打印</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypeCopyToPasteboard</span>   <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) __TVOS_PROHIBITED;    <span class="comment">//拷贝</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypeAssignToContact</span>    <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) __TVOS_PROHIBITED;    <span class="comment">//指定给联系人</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypeSaveToCameraRoll</span>   <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) __TVOS_PROHIBITED;    <span class="comment">//保存至相机胶卷</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypeAddToReadingList</span>   <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0) __TVOS_PROHIBITED;    <span class="comment">//添加至阅读列表</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypePostToFlickr</span>       <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0) __TVOS_PROHIBITED;    <span class="comment">//发送到Flickr(雅虎旗下图片分享网站)</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypePostToVimeo</span>        <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0) __TVOS_PROHIBITED;    <span class="comment">//发送到Vimeo</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypePostToTencentWeibo</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0) __TVOS_PROHIBITED;    <span class="comment">//发送到腾讯微博</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypeAirDrop</span>            <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0) __TVOS_PROHIBITED;    <span class="comment">//AirDrop</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIActivityTypeOpenInIBooks</span>       <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0) __TVOS_PROHIBITED;    <span class="comment">//在iBooks中打开</span></span><br></pre></td></tr></table></figure><blockquote><p>如果是iOS11以下的系统，上面的分享功能应该没什么问题。但是在iOS11上面出现了Twitter和Facebook都不能分享的问题（微信、微博等正常）。</p></blockquote><p>在iOS11上面分享这两个平台点击logo以后没有任何反应。下面开始排查问题。</p><ul><li><h5 id="猜想一：系统移除掉内置社交平台后，Twitter和Facebook的App没有更新"><a href="#猜想一：系统移除掉内置社交平台后，Twitter和Facebook的App没有更新" class="headerlink" title="猜想一：系统移除掉内置社交平台后，Twitter和Facebook的App没有更新"></a>猜想一：系统移除掉内置社交平台后，Twitter和Facebook的App没有更新</h5><p>升级手机中这两个App，<strong>更新后无效</strong>。但是找到了一些资料<br><a href="https://twittercommunity.com/t/bug-in-ios-11/91490/9" target="_blank" rel="noopener">Twitter - Developers:Bug in iOS 11?</a><br>Twitter 官方说已经针对iOS11进行了更新适配</p></li><li><h5 id="猜想二：国内特供版？接口封掉了"><a href="#猜想二：国内特供版？接口封掉了" class="headerlink" title="猜想二：国内特供版？接口封掉了"></a>猜想二：国内特供版？接口封掉了</h5><p>iOS10上面一切正常，但是考虑到iOS11系统的改变，所以删掉中国App Store下载的App，登录美国App Store 账号下载这两个App。打开后依旧。<strong>无效</strong></p><blockquote><p>此时发现系统相册中的分享，点击Facebook和Twitter也无反应。所以应该和App无关</p></blockquote></li><li><h5 id="猜想三：Great-Wall"><a href="#猜想三：Great-Wall" class="headerlink" title="猜想三：Great Wall"></a>猜想三：Great Wall</h5><p>香港的朋友试试他的手机。<strong>依旧无解</strong></p></li><li><h5 id="猜想四：iOS11系统版本bug，没更新"><a href="#猜想四：iOS11系统版本bug，没更新" class="headerlink" title="猜想四：iOS11系统版本bug，没更新"></a>猜想四：iOS11系统版本bug，没更新</h5><p>都更新到最新的iOS11.1.2(正式版)。<strong>问题依旧</strong></p></li><li><h5 id="猜想五：手机的原因，因为是国行"><a href="#猜想五：手机的原因，因为是国行" class="headerlink" title="猜想五：手机的原因，因为是国行"></a>猜想五：手机的原因，因为是国行</h5><p>以上几种情况使用了不同的机型测试，但是都是国行手机。但是现在都是全网通并且国外卖的手机也都是大陆产的，所以一开始就没考虑这个。以上猜想都否决以后开始想到这个原因。<br>找了一圈，最后测试发现</p><blockquote><p>印度买的iPhone 5S在iOS11上分享Facebook和Twitter 成功<br>日本买的iPhone 8 Plus 在iOS11上面分享成功<br>并且iOS11的系统有11.1.2和11.1.0的</p></blockquote></li></ul><blockquote><p>所以最后结论是在iOS11上面移除掉了系统内置分享后，国行手机对Facebook 和Twitter 的原生分享都失效了。但是除了国行以外的手机应该都没问题。</p></blockquote><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>只有自己接入Facebook和Twitter的SDK，去官网注册key不再使用系统的。<br>但是考虑到我们的用户群都是外国人，国行手机占有率很低，所以我们忽略了这个Bug(如果是Bug的话)，毕竟国内常用的微信、微博、QQ一切正常。</p><p>这个问题我会持续追踪，看看后期系统更新会不会解决这个问题。另外我也在Twitter官网上提问了。目前为止还没有回应。</p><p><a href="https://twittercommunity.com/t/in-ios11-use-uiactivityviewcontroller-to-share-have-no-reaction/97486" target="_blank" rel="noopener">In iOS11,Use UIActivityViewController to share have no reaction</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在做针对国外用户的App，考虑到国外都是Facebook和Twitter等社交平台，所以考虑使用iOS系统中的原生分享。但是在iOS11上面遇到一些坑，遂记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在iOS11以下的版本中，系统默认集成了社交账号的功能。但是在iOS11中内置的社交账号被移除了。并且在iOS11中废弃了一些方法。&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SOCIAL_EXTERN NSString *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SLServiceTypeTwitter NS_DEPRECATED(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;_8, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;_13, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SOCIAL_EXTERN NSString *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SLServiceTypeFacebook NS_DEPRECATED(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;_8, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;_13, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SOCIAL_EXTERN NSString *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SLServiceTypeSinaWeibo NS_DEPRECATED(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;_8, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;_13, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SOCIAL_EXTERN NSString *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SLServiceTypeTencentWeibo NS_DEPRECATED(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;_8, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;_13, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SOCIAL_EXTERN NSString *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SLServiceTypeLinkedIn NS_DEPRECATED(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;_8, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;_13, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Xcode使用技巧：代码块的使用</title>
    <link href="http://yoursite.com/2017/05/30/Xcode%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/05/30/Xcode%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2017-05-30T08:57:00.000Z</published>
    <updated>2020-07-14T09:07:21.806Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>代码块是Xcode中很便利的一个功能，你可以自定义不同的代码块，特别是对于一些需要重复写的代码，使用代码块可以大大的提高效率。</p></blockquote><p><strong>代码块介绍</strong></p><p> 代码块这个功能大家其实都用过，当你在写一些代码时候，代码提示功能就会显示出一些系统定义好的代码块。如图就是系统定义好的if else的代码块。<br>    <img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714165733.png" alt=""><br>    代码块在右侧边栏的下方，在这里你可以看到系统定义的代码块也可以自定义你自己的代码块。<br>    <img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714165820.png" alt=""></p><pre><code>下图就是系统定义好的dispathc_once_t的代码块。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714165857.png" alt=""></p><p><strong>定义自己的代码块</strong></p><p>定义自己的代码块有很多好处，你可以随心所欲的根据自己的项目和喜好定义自己的代码块。<br>比如一些@property属性，一些三方的统计功能等等。下面我们来定义一个代码块，来快速定    义@property 修饰符为nonatomic和strong</p><p>首先在任意一个类下面声明如下的属性 type 和 name 为提示语<br>    <figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nonatomic,strong) <span class="keyword">type</span> name;</span><br></pre></td></tr></table></figure><br><strong>然后把type 和 name 上分别改为&lt;#type#&gt; 和 &lt;#name#&gt;</strong></p><pre><code>你会发现 type 和name 都变成了高亮状态，你可以按Tab键来切换。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714170047.png" alt=""><br>  是不是发现变成和系统的一样了？你可以很方便的在高亮地方写入你需要的代码，然后按Tab键来回切换。<br>  <img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714170116.png" alt=""><br>   然后全选你刚刚写的那行代码，拖拽到代码块界面所在的区域。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714170138.png" alt=""><br>然后会弹出一个界面，在这里填写你的代码块的信息。<br>Title就是在代码块管理区域显示的名称。重要的下面的Completion Shortcut，这就是你的代码块的快捷键，<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714170203.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714170223.png" alt=""></p><p>然后点击Done。你的代码块就会出现在列表中了。去代码区试一下<br>输入@ps 就会出现你的代码块提示，按回车后刚刚定义的代码就出现了~<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714170247.png" alt=""></p><p>代码块的好处是不言而喻的，绝对是提高效率的利器。比如我们之前的项目要接入好多第三方的统计功能，然而每个界面挨个复制挨个改很浪费时间（当然也可以使用runtime直接在Viewcontroller 的load方法写，但是就不能自定义一些东西了）。使用代码块后就会很方便的完成这些工作啦。<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714170305.png" alt=""></p><p>再举个栗子。Xcode8以后禁用了第三方插件，之前使用的多行注释插件(就是喵神写的那个)也被废弃了。虽然Xcode8提供了系统的，但是不太好用，你也可以使用代码块来自定义多行注释。<br>（快捷键定义为 “///“ 并不会按回车就会出来，而是需要按esc才能提示，所以我用了“ccc”）</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200714170324.png" alt=""></p><p><strong>代码块的存放路径为 ~/Library/Developer/Xcode/UserData/CodeSnippets</strong></p><p>大家可以从网上下载一些大神写好的，也可以自己写完以后备份，防止丢失。<br>上个地址吧，我自己定义的一些，没怎么管理，有点乱</p><p><a href="https://github.com/liweican1992/XcodeCodeSnippets.git" target="_blank" rel="noopener">https://github.com/liweican1992/XcodeCodeSnippets.git</a></p><p>PS：关于统计埋点，我自己根据Runtime写了一些统计功能，回头补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;代码块是Xcode中很便利的一个功能，你可以自定义不同的代码块，特别是对于一些需要重复写的代码，使用代码块可以大大的提高效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;代码块介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 代码块这个功能大
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Apple审核那点事：被拒后如何申诉</title>
    <link href="http://yoursite.com/2017/05/07/Apple%E5%AE%A1%E6%A0%B8%E9%82%A3%E7%82%B9%E4%BA%8B%EF%BC%9A%E8%A2%AB%E6%8B%92%E5%90%8E%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%89/"/>
    <id>http://yoursite.com/2017/05/07/Apple%E5%AE%A1%E6%A0%B8%E9%82%A3%E7%82%B9%E4%BA%8B%EF%BC%9A%E8%A2%AB%E6%8B%92%E5%90%8E%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%89/</id>
    <published>2017-05-07T08:02:00.000Z</published>
    <updated>2020-06-01T08:35:04.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随着Apple审核时间的大大加快，确实造福了我们这些苦逼的开发者。今天主要聊一些审核被拒以后如果中间存在误会什么的，如何向苹果申诉。<br>  关于申诉，我之前的博客就提及过，详见： <a href="http://www.cnblogs.com/cc412/p/5006029.html" target="_blank" rel="noopener">关于审核被拒申诉那点事</a><br>  但是考虑到时间这么久了，有一些规则可能发生变化，就再重新开一篇。</p></blockquote><p>  苹果的审核总是充满了随机性，之前用的好好的一个功能就会忽然告诉你不符合他们的标准了。这次提交审核总共被拒绝了两次，第一次是因为版本号，第二次因为服务器机房挂了。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601160409.png" alt=""></p><a id="more"></a><blockquote><p>Design Preamble<br>Your app includes an update button or alerts the user to update the app. To avoid user confusion, app version updates must utilize the iOS built-in update mechanism.<br>Specifically, the 關於我們 button contains reference to the version number. Although the 關於我們 button does not contain update functionality, it will be appropriate to remove this responsive feature.<br>Please see attached screenshots for details.<br>Next Steps<br>To resolve this issue, please remove the update feature from your app. To distribute a new version of your app, upload the new app binary version into the same iTunes Connect record you created for the app’s previous version. Updated versions keep the same Apple ID, iTunes Connect ID (SKU), and bundle ID as the original version, and are available free to customers who purchased a previous version.<br>Resources<br>To create new versions of your app, please review the Create a new version section in iTunes Connect Developer Help.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601160421.png" alt=""></p><p>大意就是我们在关于我们后面加了一个版本号，会让用户以为点击这里可以检测版本，因为苹果禁止主动的版本检测功能（详见：<a href="http://www.jianshu.com/p/3b5dc03099b5" target="_blank" rel="noopener">关于iOS App 版本控制以及强制更新</a>和<a href="http://www.cnblogs.com/cc412/p/4371148.html" target="_blank" rel="noopener">苹果新政，禁止开发者在App中加入检查更新功能</a>），所以给拒了。</p><p>最后在下方增加一个不能点击的当前版本功能解决此问题。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601160439.png" alt=""></p><p>继续提交，这次一天就审核了，可能现在苹果在被拒以后再次提交走的通道不一样。然而苹果晚上审核时候刚好我们服务器机房网络波动，给的测试账号一直登不上去，再次被拒绝。</p><blockquote><p>Guideline 2.1 - Performance<br>We discovered one or more bugs in your app when reviewed on iPhone running iOS 10.3.1 on Wi-Fi connected to an IPv6 network.<br>Specifically, we were not able to log into the application with the demo credentials provided.<br>-The application remained at the login menu as we attempted to log in.<br>The steps to reproduce are:</p><ol><li>Lauch application</li><li>Navigate to login screen</li><li>Enter demo credentials/ credentials</li><li>Tap log in<br>Please see attached screenshots for details.<br>Next Steps<br>To resolve this issue, please run your app on a device while connected to an IPv6 network (all apps must support IPv6) to identify any issues, then revise and resubmit your app for review.<br>If we misunderstood the intended behavior of your app, please reply to this message in Resolution Center to provide information on how these features were intended to work.<br>For new apps, uninstall all previous versions of your app from a device, then install and follow the steps to reproduce the issue. For updates, install the new version as an update to the previous version, then follow the steps to reproduce the issue.<br>Resources<br>For information about supporting IPv6 Networks, please review Supporting IPv6 DNS64/NAT64 Networks and About Networking.</li></ol></blockquote><p>苹果给出的意见是做IPV6的适配，他们怀疑是IPV6的原因造成无法访问，而之前我们IPV6没出现过问题，并且查看服务器日志，昨天晚上确实出现了警报。那么下一步就是要和苹果解释了。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601160500.png" alt=""></p><p>在被拒绝下方有一个回复框，你在这里可以向苹果解释误会以及一些操作步骤。使用中文就可以。但是要注意，不要使用上方的<strong>向App审查委员会提交上诉</strong></p><blockquote><p>苹果审核有两个部门，一个是Resolution Center另外一个是App Review Board。App Review Board就是审核委员会，他们的级别高于Resolution Center。当你对Resolution Center给出的原因和解决方案不满意的话，可以向更高一级的App Review Board提出上诉。<br>但是请注意<strong><em>如果你已经回复过了Resolution Center（也就是下方的输入框哪里）而他们还没有给你回应时候，不要再点击上方的向“App审查委员会提交上诉”</em></strong></p></blockquote><p>因为你会像我一样收到一封邮件</p><blockquote><p>Hello xxx,<br>Thank you for contacting the App Review Board.<br>We see that you’re currently communicating with the App Store Review team through the Resolution Center, so we’re closing your appeal. If you would like to continue the appeal process, please reply to this message to let us know.<br>Best regards.<br> App Store Review Board</p></blockquote><p>所以他们是两个独立的部门，<strong>并且个人不建议你去上诉，苹果的审核人员素质还是挺高的，只要你阐明你的理由并且是合理的</strong>，一般都会给你通过。而上诉会留下类似案底的东西，对你的后续审核“可能”会造成一些不必要的麻烦。</p><p>  好吧，扯了这么多。后续就是我把机房问题阐述了一下，第二天审核就通过了。并且人家会再次给你很有礼貌的回复。一片和谐~</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601160515.png" alt=""></p><p>所以苹果的申诉机制还是很有用处的，并且我们在申诉时候一定要注意语言，别人也是履行自己的职责。还有就是要注意他们不同部门的划分。<br>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;随着Apple审核时间的大大加快，确实造福了我们这些苦逼的开发者。今天主要聊一些审核被拒以后如果中间存在误会什么的，如何向苹果申诉。&lt;br&gt;  关于申诉，我之前的博客就提及过，详见： &lt;a href=&quot;http://www.cnblogs.com/cc412/p/5006029.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于审核被拒申诉那点事&lt;/a&gt;&lt;br&gt;  但是考虑到时间这么久了，有一些规则可能发生变化，就再重新开一篇。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  苹果的审核总是充满了随机性，之前用的好好的一个功能就会忽然告诉你不符合他们的标准了。这次提交审核总共被拒绝了两次，第一次是因为版本号，第二次因为服务器机房挂了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601160409.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS APNs篇：挽救推送事故——如何“撤回”已发送的推送通知</title>
    <link href="http://yoursite.com/2017/03/01/iOS-APNs%E7%AF%87%EF%BC%9A%E6%8C%BD%E6%95%91%E6%8E%A8%E9%80%81%E4%BA%8B%E6%95%85%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E2%80%9C%E6%92%A4%E5%9B%9E%E2%80%9D%E5%B7%B2%E5%8F%91%E9%80%81%E7%9A%84%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5/"/>
    <id>http://yoursite.com/2017/03/01/iOS-APNs%E7%AF%87%EF%BC%9A%E6%8C%BD%E6%95%91%E6%8E%A8%E9%80%81%E4%BA%8B%E6%95%85%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E2%80%9C%E6%92%A4%E5%9B%9E%E2%80%9D%E5%B7%B2%E5%8F%91%E9%80%81%E7%9A%84%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5/</id>
    <published>2017-03-01T08:29:00.000Z</published>
    <updated>2020-06-01T08:35:11.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简书旧文</p></blockquote><blockquote><p>推送服务在日常运营中至关重要，就算是大厂也经常发生推送事故。相信很多人都收到过名为“test”的推送信息。本篇将介绍如何在推送事故发生时“撤回”已发送的推送通知。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163016.png" alt=""></p><p>细心的用户会发现当微信消息被撤回或者视频请求被取消时，相应的推送信息也会消失不见。哪怕是微信没有在后台运行。</p><p>本人很是好奇，网上又没有查到有用的资料，今天花了点时间实现了类似的功能。</p><a id="more"></a><p>那么如何实现呢，请往下看。</p><ul><li><h3 id="猜想其原理"><a href="#猜想其原理" class="headerlink" title="猜想其原理"></a>猜想其原理</h3></li></ul><p>“撤回”这里是打了引号的，我翻看了下APNs资料并没有找到撤回的接口。<br>关于详细的APNs介绍可以参考这里：<a href="http://www.jianshu.com/p/ace1b422bad4" target="_blank" rel="noopener">国内 90%以上的 iOS 开发者，对 APNs 的认识都是错的</a>。</p><p>微信的消息提醒应该走的也是苹果的APNs通道，当微信在后台kill掉时候推送消息过来后再撤回，依旧可以“撤回”这个通知。但这时候App根本就没有在后台运行，<strong>那么应该还是走APNs通道来发一条新推送去除掉之前那条。</strong><br>用新推送来去除旧的推送，并且新推送不显示。那么方案应该就是<strong>静默推送（Silent Remote Notifications）</strong>了</p><ul><li><h3 id="静默推送"><a href="#静默推送" class="headerlink" title="静默推送"></a>静默推送</h3></li></ul><p>静默推送（Silent Remote Notifications）是iOS7以后的新特性。特色就是可以不打扰用户，无声音无角标悄无声息的唤醒App来进行一些更新操作。</p><p>苹果官方文档如下</p><blockquote><p>Configuring a Silent Notification</p></blockquote><blockquote><p>The aps dictionary can also contain the content-available property. The content-available property with a value of 1 lets the remote notification act as a silent notification. When a silent notification arrives, iOS wakes up your app in the background so that you can get new data from your server or do background information processing. Users aren’t told about the new or changed information that results from a silent notification, but they can find out about it the next time they open your app.</p></blockquote><blockquote><p>For a silent notification, take care to ensure there is no alert, sound, or badge payload in the aps dictionary. If you don’t follow this guidance, the incorrectly-configured notification might be throttled and not delivered to the app in the background, and instead of being silent is displayed to the user.</p></blockquote><p>静默推送有一定的推送格式要求。首先不能有alert信息，如果有的话就变成普通推送了。其次APNs参数里面要有 <strong>content-available：1</strong></p><p>下图是极光推送后台对静默推送的解释</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163042.png" alt=""></p><p><strong>静默推送和普通推送的区别就是不用用户点击推送信息即可进入didReceiveRemoteNotification方法获取推送信息，无论App是否在后台运行</strong></p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">application</span><span class="selector-pseudo">:(UIApplication</span> *)<span class="selector-tag">application</span> <span class="selector-tag">didReceiveRemoteNotification</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">userInfo</span> <span class="selector-tag">fetchCompletionHandler</span><span class="selector-pseudo">:(void</span> (^)(UIBackgroundFetchResult))<span class="selector-tag">completionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以无论App是否在后台运行，我们都可以发送一个静默推送去让App处理一些事情。比如资讯类App每天定点推送让App后台静默更新当天的推荐文章。用户打开后不再需要加载就可以观看等等这类需求。</p><p>静默推送收到以后，userInfo结构如下，你可以添加自定义参数去处理一些事情</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    aps =     &#123;</span><br><span class="line">        alert = <span class="string">""</span><span class="comment">;</span></span><br><span class="line">        <span class="string">"content-available"</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        <span class="string">"mutable-content"</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">    //自己自定义的参数</span><br><span class="line">    recall2 = true<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我自定义recall参数，<strong>当收到的APNs的userInfo中包含recall时候就代表我要清除所有角标和推送信息。这样就达到了“撤回”的效果</strong></p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">application</span><span class="selector-pseudo">:(UIApplication</span> *)<span class="selector-tag">application</span> <span class="selector-tag">didReceiveRemoteNotification</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">userInfo</span> <span class="selector-tag">fetchCompletionHandler</span><span class="selector-pseudo">:(void</span> (^)(UIBackgroundFetchResult))<span class="selector-tag">completionHandler</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (application.applicationState == UIApplicationStateActive) &#123;</span><br><span class="line">        <span class="selector-tag">NSLog</span>(@<span class="string">"App在前台运行时候收到推送,不处理"</span>);    </span><br><span class="line">        <span class="selector-tag">completionHandler</span>(UIBackgroundFetchResultNewData);</span><br><span class="line">        <span class="selector-tag">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"在后台运行点击推送或者静默推送"</span>);</span><br><span class="line">    <span class="selector-tag">if</span> ([userInfo <span class="attribute">objectForKey</span>:@<span class="string">"recall"</span>]) &#123;</span><br><span class="line">        <span class="selector-tag">NSLog</span>(@<span class="string">"撤回消息"</span>);</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;<span class="selector-tag">else</span>&#123;</span><br><span class="line">         <span class="comment">//自己写的推送处理方法</span></span><br><span class="line">        <span class="selector-attr">[self didRegisterFormApnsWithInfo:userInfo]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除角标 去除推送信息</span></span><br><span class="line">    <span class="selector-attr">[application setApplicationIconBadgeNumber:0]</span>;</span><br><span class="line">    <span class="selector-attr">[JPUSHService resetBadge]</span>;</span><br><span class="line">    <span class="selector-attr">[JPUSHService handleRemoteNotification:userInfo]</span>;</span><br><span class="line">    <span class="selector-tag">completionHandler</span>(UIBackgroundFetchResultNewData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真机运行，实测在后台运行和Kill掉都可以去除之前的推送信息，包括锁屏状态。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163058.png" alt=""></p><p>到此我们就实现了推送的“撤回”功能。从此妈妈再也不怕我发错推送啦,公司发错推送以后再也不用实习生背锅啦~</p><blockquote><p>注：以上解决方案只是个人猜想后实现的，如果你有更好的方案或解决机制，欢迎讨论~如果文章对你有帮助，点个赞再走呗🤔</p></blockquote><p>转载请注明出处，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简书旧文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;推送服务在日常运营中至关重要，就算是大厂也经常发生推送事故。相信很多人都收到过名为“test”的推送信息。本篇将介绍如何在推送事故发生时“撤回”已发送的推送通知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163016.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;细心的用户会发现当微信消息被撤回或者视频请求被取消时，相应的推送信息也会消失不见。哪怕是微信没有在后台运行。&lt;/p&gt;
&lt;p&gt;本人很是好奇，网上又没有查到有用的资料，今天花了点时间实现了类似的功能。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Xcode8 和iOS10 做APNS适配的一些坑</title>
    <link href="http://yoursite.com/2016/09/21/Xcode8-%E5%92%8CiOS10-%E5%81%9AAPNS%E9%80%82%E9%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2016/09/21/Xcode8-%E5%92%8CiOS10-%E5%81%9AAPNS%E9%80%82%E9%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</id>
    <published>2016-09-21T12:50:00.000Z</published>
    <updated>2020-06-24T16:05:35.822Z</updated>
    
    <content type="html"><![CDATA[<p>iOS10已经发了，最近发现App在iOS10上有一些问题，主要是iOS10的字体变了，一些Label要做适配。还有一些相机权限之类的。更加详细的可以参考这篇文章<br><a href="https://github.com/ChenYilong/iOS10AdaptationTips" target="_blank" rel="noopener">https://github.com/ChenYilong/iOS10AdaptationTips</a></p><p>  之前一直纠结要不要升级Xcode8，毕竟好多插件都不能用了，还有用Xcode7打包的App在iOS10上运行能不能收到推送，经过一天的测试。结果如下：<br>  以下结果是我用极光推送测试的结果（JPush）</p><h4 id="Xcode7打包的App能不能再iOS10上收到推送？"><a href="#Xcode7打包的App能不能再iOS10上收到推送？" class="headerlink" title="Xcode7打包的App能不能再iOS10上收到推送？"></a>Xcode7打包的App能不能再iOS10上收到推送？</h4><p>  答案：可以的，能够收到推送。但是点击推送或者从推送启动App之前的方法不再响应。</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">application</span><span class="selector-pseudo">:(UIApplication</span> *)<span class="selector-tag">application</span> <span class="selector-tag">didReceiveRemoteNotification</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">userInfo</span> <span class="selector-tag">fetchCompletionHandler</span><span class="selector-pseudo">:(void</span> (^)(UIBackgroundFetchResult))<span class="selector-tag">completionHandler</span> &#123;</span><br><span class="line">  <span class="comment">//iOS7以后收到推送 推送结果会在这里响应 </span></span><br><span class="line">  <span class="comment">//iOS10 以后不再响应这里</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>也就是只能收到，但是点击推送以后只会打开App而不会走didReceiveRemoteNotification，所以页面不跳转。<br>（我是用AD_Hoc证书发了一个测试版。用iOS10的机子装上以后使用推送生产环境推送测试的。AppStore版本没测试）</p><h4 id="Xcode8升级以后怎么做iOS10适配"><a href="#Xcode8升级以后怎么做iOS10适配" class="headerlink" title="Xcode8升级以后怎么做iOS10适配"></a>Xcode8升级以后怎么做iOS10适配</h4><p>我是根据最新的Jpush官方文档做的适配<br><a href="https://docs.jiguang.cn/jpush/client/iOS/ios_guide_new/" target="_blank" rel="noopener">https://docs.jiguang.cn/jpush/client/iOS/ios_guide_new/</a></p><p>需要注意的几点：</p><h6 id="1-Xcode8的疯狂输出模式"><a href="#1-Xcode8的疯狂输出模式" class="headerlink" title="1.Xcode8的疯狂输出模式"></a>1.Xcode8的疯狂输出模式</h6><p>  刚用Xcoed8时候吓着了，疯狂输出一大堆log信息。建议关闭掉。<br>关闭办法</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200624235419.png" alt=""><br>进入地方在你选择模拟器的左边有一个你的App图标和名字，点击一下选择Edit Scheme。 然后选择Run-&gt;Environment Variables-&gt;+号</p><blockquote><p>OS_ACTIVITY_MODE =disable </p></blockquote><p>然后打钩，完事</p><blockquote><p>但是Xcode8的NSLog不打印了 = =！我这边是这个情况</p></blockquote><h6 id="2-Push-Notification开关"><a href="#2-Push-Notification开关" class="headerlink" title="2.Push Notification开关"></a>2.Push Notification开关</h6><p>  刚在Xcode8上运行时候肯定会报错。需要在Tragets-&gt;Capabilites打开Push Notification开关。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200624235524.png" alt=""><br>点击修复后会自动生成一个xxx.entitlements的文件（xxx是你的工程名字）</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200624235914.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200625000350.png" alt=""><br>你会发现里面会有APS Environment 并且为development<br>那你需要上线时候改成发布吗？<br> <strong>并不用</strong>可以忽略它，它对你发布并无影响。只要你发布时候选择的是发布证书依旧是发布环境。</p><blockquote><p>但是，如果你用Xcode8生成以后再用Xcode7打开，如果不删除这个文件，打包时候就会报错，<del>所以如果你想用Xcode8做完适配以后还想用Xcode7发包的话请删除掉这个文件。（然后删除掉会报错）把下图选中哪行后面的路径删掉就好了</del></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img2/20200625000434.png" alt=""></p><blockquote><p>更新：昨天试了下，删除这个文件再用Xcode7打包以后安装到iOS10可以收到推送但是还是不响应推送处理的方法。<br>暂时解决办法是使用Xcode7开发最后发版使用Xcode8<br>Xcode7打包报错应该有解决办法，暂时留个坑</p></blockquote><p><strong>代码适配</strong><br>因为用的第三方，所以按着文档来就好了，但是也有一些小坑</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NSFoundationVersionNumber_iOS_9_x_Max</span></span><br><span class="line"><span class="comment">//在这里写针对iOS10的代码或者引用新的API</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UserNotifications/UserNotifications.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NSFoundationVersionNumber_iOS_9_x_Max</span></span><br><span class="line">- (<span class="keyword">void</span>)jpushNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSInteger</span>))completionHandler &#123;</span><br><span class="line">    <span class="comment">// Required</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> * userInfo = notification.request.content.userInfo;</span><br><span class="line">    <span class="keyword">if</span>([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        [JPUSHService handleRemoteNotification:userInfo];</span><br><span class="line">        [JPUSHService resetBadge];</span><br><span class="line">        <span class="comment">///在前台时候收到推送 iOS10App运行在前台推送来了也能显示哦</span></span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler(UNNotificationPresentationOptionAlert); <span class="comment">// 需要执行这个方法，选择是否提醒用户，有Badge、Sound、Alert三种类型可以选择设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 10 Support</span></span><br><span class="line">- (<span class="keyword">void</span>)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(<span class="keyword">void</span> (^)())completionHandler &#123;</span><br><span class="line">    <span class="comment">// Required</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> * userInfo = response.notification.request.content.userInfo;</span><br><span class="line">    <span class="keyword">if</span>([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        [JPUSHService resetBadge];</span><br><span class="line">      <span class="comment">///这个是我自己处理推送的方法 忽略掉</span></span><br><span class="line">        [<span class="keyword">self</span> didRegisterFormApnsWithInfo:userInfo];</span><br><span class="line">        [JPUSHService handleRemoteNotification:userInfo];</span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler();  <span class="comment">// 系统要求执行这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>有趣的是iOS10当App正在运行时候也可以在上方弹出推送框</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS10已经发了，最近发现App在iOS10上有一些问题，主要是iOS10的字体变了，一些Label要做适配。还有一些相机权限之类的。更加详细的可以参考这篇文章&lt;br&gt;&lt;a href=&quot;https://github.com/ChenYilong/iOS10Adaptati
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Apple开发账号续费流程及Tips（17年7月更新）</title>
    <link href="http://yoursite.com/2016/07/17/Apple%E5%BC%80%E5%8F%91%E8%B4%A6%E5%8F%B7%E7%BB%AD%E8%B4%B9%E6%B5%81%E7%A8%8B%E5%8F%8ATips%EF%BC%8817%E5%B9%B47%E6%9C%88%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/17/Apple%E5%BC%80%E5%8F%91%E8%B4%A6%E5%8F%B7%E7%BB%AD%E8%B4%B9%E6%B5%81%E7%A8%8B%E5%8F%8ATips%EF%BC%8817%E5%B9%B47%E6%9C%88%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2016-07-17T08:47:00.000Z</published>
    <updated>2020-06-01T06:22:52.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文为简书旧文</p></blockquote><p>最近公司开发者账号马上到期了，需要进行续费工作。现在记录一下流程和遇到的一些坑。<br>  首先登陆开发者中心<a href="https://developer.apple.com/" target="_blank" rel="noopener">https://developer.apple.com/</a><br>  选择右上方的Account,然后输入账号和密码。<strong><em>进入后如果过期时间小于30天，在首页会给你一个小弹窗告诉你要续费。</em></strong></p><blockquote><p>update<br>补充下图片，当还有一个月过期时候，登录iTunes Connect 或者开发者中心都会有提示信息</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141646.png" alt=""></p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141702.png" alt=""></p><p>点击任意入口。登录开发者账号，会进入到付款界面</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141713.png" alt=""><br>选择VISA还是MasterCard。国内银联当然是不支持啦，但是这里要注意，招商银行VISA全币卡（就是黑色那张）是不能用的！</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141723.png" alt=""><br>  后来查了下，说要去招行官网开通什么结算通道，但是开通以后依旧不行，还有人说要使用VISA和银联双标卡，说苹果关闭了国内银行发行的VISA单标卡的结算通道。总之用不了啊。。。</p><p><strong><em>update</em></strong></p><blockquote><p>评论有小伙伴反应招行Visa单标卡验证失败的原因是<br>可能是因为没有开通：<br>1：网上支付功能<br>2：VISA验证服务</p></blockquote><blockquote><p>我记得当时我有去招行官网开通VISA验证服务，至于网上支付功能这个应该是开通着的，但是时间太久就不得了。如果有小伙伴出现招行单标卡验证失败的情况，请尝试上述两种方法。有结果的话麻烦留言告知一下~</p></blockquote><p>  因为我的招行万事达卡还在申请的路上，所以我也没办法尝试招行的Mastercard能不能用。最后用了同事一张国外的Mastercard付费成功。</p><blockquote><p>update 17年7月<br>发票问题<br>17年税改以后发票报销不能只写公司抬头了，还要写税号。但是苹果给的界面并没有填写入口。但是却说可以电话订购。<br>如果有小伙伴有电话订购的经历，欢迎留言补充。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141846.png" alt=""></p><p>   付费以后过几分钟会收到Apple发的邮件，一个是订单确认邮件一个是电子收据</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141857.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141942.png" alt=""></p><blockquote><p>update 17年<br>今年续费出现一种新情况，24小时以后再看结果好了</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142001.png" alt=""></p><blockquote><p>上面那个挂掉了，说订单失败，重新换了一个信用卡</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142017.png" alt=""></p><p>因为写的联系和发票邮箱不是Apple开发者账号那个主邮箱，登录开发者账号主邮箱，会有一封名为“Thank you for purchasing an Apple Developer Program ”的邮件。</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142029.png" alt=""><br>邮件中会告诉你你已经续费成功，并且到期日期也确实更新了。<br>but！！！<br>当我回到开发者中心的MembersShip里面查看<br><strong>到期信息还是依旧！</strong><br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142055.png" alt=""></p><p>WTF! 然后上网找资料，有人说要去主账号邮箱找一个激活码，用激活码激活，但是里面根本没有这个邮件！<br>因为怕账号到期App被下架，所以我发邮件咨询了苹果官方。具体入口在<br>开发者中心首页-&gt;右上方Support-&gt;右下角Contact Us。然后<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142105.png" alt=""></p><p>Then<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142136.png" alt=""></p><p>Ok，过了小半天就收到Apple的回复邮件了</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601142147.png" alt=""></p><p>原来苹果信息更新也是很不及时的，但终究续费成功。<br>Done~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此文为简书旧文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近公司开发者账号马上到期了，需要进行续费工作。现在记录一下流程和遇到的一些坑。&lt;br&gt;  首先登陆开发者中心&lt;a href=&quot;https://developer.apple.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.apple.com/&lt;/a&gt;&lt;br&gt;  选择右上方的Account,然后输入账号和密码。&lt;strong&gt;&lt;em&gt;进入后如果过期时间小于30天，在首页会给你一个小弹窗告诉你要续费。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;update&lt;br&gt;补充下图片，当还有一个月过期时候，登录iTunes Connect 或者开发者中心都会有提示信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601141646.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS开发中一些小工具</title>
    <link href="http://yoursite.com/2016/03/25/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2016/03/25/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2016-03-25T08:36:00.000Z</published>
    <updated>2020-06-02T02:56:22.595Z</updated>
    
    <content type="html"><![CDATA[<p>做iOS开发已经有几年了，中间也积累下了不少工具<br>做一个总结吧</p><p><strong>一、Mac 菜单栏工具</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163902.png" alt=""></p><ul><li>Bartender</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163920.png" alt=""></p><p>Barteder是一款优秀的菜单栏管理工具，可以把一些不常用的隐藏起来，将大量的菜单有选择折进 Bartender 的二级菜单，不仅会看起来更整洁，使用起来也不会造成太大的麻烦。配合下面的 <strong><em>iStar Menus</em></strong> 食用更加<br>官网地址：<a href="https://www.macbartender.com/" target="_blank" rel="noopener">https://www.macbartender.com/</a><br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163937.png" alt=""></p><ul><li>iStar Menus</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163949.png" alt=""><br>这个工具可以监测Mac的各种性能，并且可以就改样式颜色等。装逼利器之一~</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164010.png" alt=""><br>官网地址:<a href="https://bjango.com/mac/istatmenus/" target="_blank" rel="noopener">https://bjango.com/mac/istatmenus/</a></p><a id="more"></a><ul><li>Alfred2<br>神兵利器，工作流典范</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164023.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164043.png" alt=""><br>总之，只有你想不到没有你做不到<br>网上教程较多，有很多其他人写好的workflow，可以直接拿来使用<br>官方地址：<a href="https://www.alfredapp.com/" target="_blank" rel="noopener">https://www.alfredapp.com/</a></p><p><strong><em>二、实用类 开发工具</em></strong></p><ul><li>Switcher<br>可以方便的切换各个国家的App Store，看在各区的排名和评论。国际化项目的开发利器</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164112.png" alt=""><br>安装地址：<a href="http://switchr.imagility.io/" target="_blank" rel="noopener">http://switchr.imagility.io/</a><br>浏览器打开，保存至桌面即可</p><ul><li>Sourcetree<br>git界面化工具，使用最多的软件了没啥好讲的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164128.png" alt=""></p><ul><li>kaleidoscope</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164140.png" alt=""><br>配合Sourcetree使用用于多人开发时解决冲突使用，我会单独写一篇博客介绍其安装和使用</p><ul><li>PostMan</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164152.png" alt=""><br>Chorme插件<br>接口调试利器 ，发送各种请求，看接口的返回样式等等等<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164216.png" alt=""><br>安装： chorme应用商店搜索postman</p><p><strong><em>需翻墙！！！<br>选择扩展程序那个安装</em></strong><br>下面有翻墙软件 往后翻<br><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164243.png" alt=""></p><ul><li>Lantern</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164256.png" alt=""><br>长城的存在是保护外国人的（笑），奈何做开发还是需要翻墙的<br>免费的！你懂得</p><ul><li>MarkMan<br>淘宝，鹅厂都在用的工具，取色量取尺寸神器，60软妹币一年，当然你可以不付费，不付费除了不能保存一切都一样。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164307.png" alt=""></p><ul><li>Hex color picker<br>Xcode颜色神器，上面介绍了markman的取色功能，那么在开发中用代码赋值颜色多麻烦啊。因为我使用storyboard比较多，所以Hex color picker用到的比较多。<br>先放一个下载地址 <a href="https://pan.baidu.com/s/1dFM92Kx" target="_blank" rel="noopener">https://pan.baidu.com/s/1dFM92Kx</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164323.png" alt=""><br>恩，大概就是这个样子，可以在storyboard中直接用16进制颜色赋值。<br>安装办法：把整个文件夹copy到资源库中（需要输入本机密码），文件夹命名为ColorPickers，然后重启Xcode即可</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164340.png" alt=""></p><ul><li>Chrales<br>抓包神器，不管是调试接口还是想看其他App的接口数据，都很好用（https加密暂时还没解密出来，目前只能看http接口）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164350.png" alt=""><br>设置很简单，看你当前电脑本机IP，然后打开手机WiFi选项，点击当前连接WiFi后面的感叹号，进入设置界面，在HTTP代理那里选择手动，把电脑本机IP填进去，端口为8888.然后找一个使用http协议的App，看看其他人的接口设计吧~</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164417.png" alt=""><br>扔一个下载地址 链接: <a href="http://pan.baidu.com/s/1c27JcKK" target="_blank" rel="noopener">http://pan.baidu.com/s/1c27JcKK</a> 密码: kw27<br>（你懂的）</p><p>Update 2016-10-17</p><ul><li>Tinypng<br>App瘦身利器，当App中的图片资源越来越多时候，App的体积也会越来越大。是时候给你App中内置的图片瘦身了。使用方便，只需拖图片进去在线即可压缩。<br>地址：<a href="https://tinypng.com/" target="_blank" rel="noopener">Tinypng</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164434.png" alt=""><br>Update 2016-11-04</p><ul><li>Prepo<br>App图标裁剪软件，iOS10 以后图标有新增两个尺寸。不过这个软件依旧可以满足。UI操作简单，一键生成所有尺寸图标。只需让UI出一个<strong><em>1024x1024</em></strong>分辨率的图就好。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164446.png" alt=""><br>上方还可以选择iOS7 +、 iPhoneOnly之类的筛选</p><p><img src="https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164457.png" alt=""><br>然后点击上方的Export导出即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做iOS开发已经有几年了，中间也积累下了不少工具&lt;br&gt;做一个总结吧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、Mac 菜单栏工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163902.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bartender&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163920.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Barteder是一款优秀的菜单栏管理工具，可以把一些不常用的隐藏起来，将大量的菜单有选择折进 Bartender 的二级菜单，不仅会看起来更整洁，使用起来也不会造成太大的麻烦。配合下面的 &lt;strong&gt;&lt;em&gt;iStar Menus&lt;/em&gt;&lt;/strong&gt; 食用更加&lt;br&gt;官网地址：&lt;a href=&quot;https://www.macbartender.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.macbartender.com/&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163937.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iStar Menus&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601163949.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这个工具可以监测Mac的各种性能，并且可以就改样式颜色等。装逼利器之一~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liweican1992/hexoPic/img/20200601164010.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;官网地址:&lt;a href=&quot;https://bjango.com/mac/istatmenus/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bjango.com/mac/istatmenus/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
